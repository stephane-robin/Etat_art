% ==============
% PARAMETRAGES
% à compiler en pdfLaTeX
% ==============

% GENERAL
%  type de document rapport, chapitre commence en page impaire ou paire indifféremment
\documentclass[twoside,a4paper,11pt,frenchb,openany]{report}  
%  type de document, chapitre commence en page impaire
%\documentclass[twoside,a4paper,12pt,frenchb,openright]{report} 
\title{\textbf{Rapport de stage \\ Publication du package crisprbuilder\_tb}}
\author{Stephane Robin sous la direction de Christophe Guyeux et Jean-Claude Charr}
\date{\today}

% IMPORTATION DE LIBRAIRIES
\usepackage{amssymb}  % symboles
\usepackage{amsmath}  % symboles mathématiques
\usepackage{amsfonts}  % polices de caractères
\usepackage{amscd}
\usepackage{amsthm}  % symboles mathématiques pour redéfinir les théorèmes
\usepackage[all,cmtip]{xy}
\usepackage{array}  % tableaux
\usepackage[frenchb]{babel}  % langue française
\usepackage{bm}  % caractères grecs
\usepackage{calc}
\usepackage[justification=centering]{caption} % centralise les légendes des figures
\usepackage{enumitem} % listes
\usepackage{eurosym}  % symbole euro
\usepackage{euscript}
\usepackage{fancybox}  % boîtes
\usepackage{float}  % images flottantes
\usepackage[T1]{fontenc}  % LaTeX modele
\usepackage[top=3.1cm,bottom=2.7cm,left=2.2cm,right=2.2cm,dvips]{geometry}  % marges
\usepackage{graphicx}  % insertion images
\usepackage{imakeidx} % make index
\usepackage[utf8]{inputenc}  % accents
\usepackage{mathrsfs}  % symboles mathématiques
\usepackage{mathtools}  % outils mathématiques
\usepackage{mdframed} % box autour des theoremes
\usepackage{pst-plot, pstricks}
\usepackage{pstricks-add}
\usepackage{rotating}
\usepackage{setspace} % permet de définir l'espace entre les lignes
\usepackage{srcltx}
\usepackage[most]{tcolorbox}
\usepackage{textcomp}   % caracteres complementaires
\usepackage{titlesec}  % sections
\usepackage{titletoc}  % table de contents
%\usepackage[nottoc,notlof,notlot]{tocbibind}  % bibliothèque
\usepackage{verbatim}  % caracteres non interpretes
\usepackage{wrapfig}  % pour inserer les figures dans du texte

% COULEURS
\definecolor{couleurTitre}{RGB}{64,128,128}  % doit être défini avant xcolor
\definecolor{couleurUrl}{RGB}{127,62,0}
\usepackage{xcolor}  % couleurs
%\definecolor{amber}{rgb}{1.0,0.49,0.0} % couleur non utilisee
%\definecolor{greyish}{rgb}{52.0,160.0,157.0} % couleur non utilisee
%\definecolor{theoremeCouleur}{rgb}{224.0,90.0,67.0} % couleur non utilisee

% LISTES
\renewcommand{\labelitemi}{$\bullet$}  % symboles de listes
\frenchbsetup{StandardLists=true}  % style de bullets

% IMAGES
\usepackage{caption}  % insertion d'images
\usepackage[font=footnotesize,labelfont=bf]{caption}  % légendes des images
\renewcommand{\thefigure}{\arabic{figure}}  % numérotation des images
%\renewcommand{\thefigure}{\arabic{section}.\arabic{figure}}  % autre possibilité numérotation des images
\usepackage{subcaption}

% HYPERLINKS
\usepackage{hyperref}
\hypersetup{
	colorlinks=true,
	linkcolor=couleurUrl,
	citecolor=couleurUrl,
	urlcolor=couleurUrl,
	breaklinks=true % saute la ligne au milieu d'un href
}
\PassOptionsToPackage{hyphens}{url}\usepackage{hyperref} % pour que url ait les memes propriétés que hyperref

% LIGNES
\usepackage{parskip}
%\setlength\parskip{\baselineskip} % joint a la suppression de l'espace horizontal
%\setlength{\parindent}{0cm} % supprime l'espace horizontal en debut de ligne

% HEADINGS AND FOOTERS
\usepackage{fancyhdr}  % entete
\pagestyle{fancy}  % la page accepte les entetes et pieds de page
\renewcommand{\headrulewidth}{0pt}
\fancyhead[L,R,C]{}
%\fancyhead[LE]{} % pages paires header gauche
%\fancyhead[CE]{} % pages paires header centre
%\fancyhead[RE]{Le théorème de Pythagore} % pages paires header droit
%\fancyhead[LO]{Le théorème de Pythagore} % pages impaires header gauche
%\fancyhead[CO]{} % pages impaires header centre
%\fancyhead[RO]{} % pages impaires header droit
%\fancyfoot[c]{\textcolor{gray}{\thepage}}  % pied de page
%\fancyfoot[L,R,C]{} % forcing footer empty

% REDEFINITION DU STYLE DE THEOREM
\newmdtheoremenv[  % definitions
linewidth=5,
leftline=true,
rightline=false,
bottomline=false,
topline=false,
leftmargin=0,
rightmargin=0,
backgroundcolor=couleurTitre!20,
linecolor=orange!70,
innertopmargin=21pt,
skipabove=\topskip,
ntheorem=true]{definition}{Définition}

\newmdtheoremenv[  % theoremes
linewidth=5,
leftline=true,
rightline=false,
bottomline=false,
topline=false,
leftmargin=0,
rightmargin=0,
backgroundcolor=couleurTitre!20,
linecolor=orange!70,
innertopmargin=10pt,
skipabove=\topskip,
ntheorem=true]{theorem}{}

\newmdtheoremenv[  % proprietes
linewidth=5,
leftline=true,
rightline=false,
bottomline=false,
topline=false,
leftmargin=0,
rightmargin=0,
backgroundcolor=couleurTitre!20,
linecolor=orange!70,
innertopmargin=21pt,
skipabove=\topskip,
ntheorem=true]{property}{Propriété}

\newmdtheoremenv[  % propositions
linewidth=5,
leftline=true,
rightline=false,
bottomline=false,
topline=false,
leftmargin=0,
rightmargin=0,
backgroundcolor=couleurTitre!20,
linecolor=couleurTitre!70,
innertopmargin=21pt,
skipabove=\topskip,
ntheorem=true]{proposition}{Proposition}

\newmdtheoremenv[  % corollaires
linewidth=5,
leftline=true,
rightline=false,
bottomline=false,
topline=false,
leftmargin=0,
rightmargin=0,
backgroundcolor=couleurTitre!20,
linecolor=couleurTitre!70,
innertopmargin=21pt,
skipabove=\topskip,
ntheorem=true]{corollary}{Corollaire}

\newmdtheoremenv[  % lemmes
linewidth=5,
leftline=true,
rightline=false,
bottomline=false,
topline=false,
leftmargin=0,
rightmargin=0,
backgroundcolor=couleurTitre!20,
linecolor=couleurTitre!70,
innertopmargin=21pt,
skipabove=\topskip,
ntheorem=true]{lemma}{Lemme}

% BOXES
\tcbset{
    frame code={}
    center title,
    left=0pt,
    right=0pt,
    top=0pt,
    bottom=0pt,
    colback=gray!20,
    colframe=white,
    width=\dimexpr\textwidth\relax,
    enlarge left by=0mm,
    boxsep=5pt,
    arc=0pt,outer arc=0pt,
    }


% NUMEROTATION DES CHAPITRES-SECTIONS
\renewcommand{\theequation}{\arabic{chapter}.\arabic{equation}}  % equations
%\renewcommand{\theequation}{\thesection\arabic{equation}}  % equations
%\numberwithin{equation}{section}  % equations

%\renewcommand{\thepart}{\Alph{part}}  % parties
%\renewcommand{\thechapter}{\arabic{chapter}.}  % chapitres
\renewcommand{\thesection}{\arabic{section}.}  % sections
\renewcommand{\thesubsection}{\arabic{section}.\arabic{subsection}.}  %  sous-sections
\renewcommand{\thesubsubsection}{\arabic{section}.\arabic{subsection}.\arabic{subsubsection}.}  % sous-sous-sections

\renewcommand{\thedefinition}{\arabic{chapter}.\arabic{definition}}  % definitions
\renewcommand{\theorem}{}  % theoremes
\renewcommand{\theproperty}{\arabic{chapter}.\arabic{property}}  % property
\renewcommand{\theproposition}{\arabic{chapter}.\arabic{proposition}}  % propositions
\renewcommand{\thecorollary}{\arabic{chapter}.\arabic{corollary}}  % corollaires
\renewcommand{\thelemma}{\arabic{chapter}.\arabic{lemma}}  % lemmes
\setcounter{tocdepth}{1} % profondeur numérotation table matières
\setcounter{secnumdepth}{3}  % profondeur de numérotation


% FORMAT DES SECTIONS-TITRES
\addto\captionsfrench{%
\renewcommand{\chaptername}{}
} % pour enlever le mot "chapitre" tout en conservant les chapitres dans la table des matières
\titleformat{\section}{\normalfont\normalsize\bfseries}{\textcolor{couleurTitre}{\thesection}}{1.2em}
{\normalfont\large\bfseries\scshape\textcolor{couleurTitre}} % format de titre de section
\titleformat{\subsection}{\normalfont\normalsize\bfseries}{\textcolor{couleurTitre}{\thesubsection}}{1em}
{\normalfont\normalsize\bfseries\textcolor{couleurTitre}}  % format de titre de sous-section
\titleformat{\subsubsection}{\normalfont\normalsize\bfseries\itshape}{\textcolor{couleurTitre}{\thesubsubsection}}{1em}
{\normalfont\normalsize\bfseries\itshape\textcolor{couleurTitre}}  % format de titre de sous-sous-section

\makeatletter

% CONCERNE LA TABLE DES MATIERES
%\renewcommand{\@chapapp}{}  % le mot `chapitre'' n'apparait plus en titre de chapitre
\renewcommand\l@section{\@dottedtocline{1}{0em}{1.5em}}  % espacement dans le titre d'une section
\renewcommand\l@subsection{\@dottedtocline{1}{2.5em}{2.5em}}  % espacement dans le titre d'une sous-section
%\renewcommand\l@subsubsection{\@dottedtocline{1}{5em}{2.5em}}  % espacement dans le titre d'une sous-sous-section

\makeatother
\makeindex

% ==============
% DEBUT DU DOCUMENT
% ==============

\begin{document}
	
\maketitle



\tableofcontents



% PREAMBULE --------------------------
\chapter{Préambule}


% REMERCIEMENTS ----------------------------
	
\section{Remerciements}
	
Je tiens à exprimer mes plus sincères remerciements à Messieurs Christophe Guyeux et Jean-Claude Charr, professeurs à l'université de Franche Comté pour m'avoir guidé, conseillé et soutenu durant le déroulement de ce stage. Leurs explcations et leur disponibilité malgré un emploi du temps chargé ont largement contribué à ma compréhension du sujet.

Je voudrais également souligner la patience dont ils ont fait preuve pour m'expliquer les notions de bioinformatique que j'ai été amené à découvrir durant ce projet. Il en ressort que j'ai particulièrement apprécié de travailler sous leur direction.

usr: ufc
pw: uni25frcomte

% PRESENTATION DU PROJET --------------------------------	
\section{Présentation du projet}

Dans le cadre d'un travail de recherche en bio-informatique, Christophe Guyeux, Jean-Claude Charr, Christophe Sola et Guislaine Refrégier ont créé du code brut leur permettant d'afficher et de stocker des données relatives à une SRA\footnote{\index{SRA}\textbf{SRA:} Sequence Read Archive} particulière. Ce code doit être rassemblé, réorganisé, nettoyé pour être conforme aux critères PEP\footnote{\index{PEP}\textbf{PEP:} Python Enhancement Proposals}. Il doit être rendu fonctionnel puis plus efficace si possible. Il doit s'exécuter en utilisant une interface en ligne de commande, et doit finalement être empaqueté pour qu'un utilisateur puisse l'utiliser quelque soit sa plateforme (Linux, macOS ou Windows) une fois installé. Pour cela, il est nécessaire de publier ce package sur PyPI\footnote{\index{PyPI}\textbf{PyPI:} Python Package Index} et de le documenter clairement en anglais pour en faciliter l'utilisation.

Lorsque nous avons défini les objectifs du stage, il est immédiatement ressorti l'importance de lui donner un caractère pratique, qui pourrait éventuellement être transposable dans le milieu professionnel.

Ainsi, l'élaboration de ce package a nécessité de passer par différentes étapes permettant de développer les compétences suivantes :
\begin{itemize}
\item amélioration des connaissances Python car il a fallu reconstruire le programme à partir d'éléments de code et chercher à optimiser les performances de traitement,
\item création d'un notebook de documentation en anglais et d'une docstring pour le package dans le respect des conventions du PEP-257,
\item création d'un environnement de développement car il a fallu tester le code pas à pas durant son élaboration,
\item utilisation de l'outil de versionnement Git, nécessaire pour sauvegarder le projet et pour revenir sur une version fonctionnelle après une modification erronée, 
\item utilisation d'un environnement de développement intégré PyCharm pour faciliter le travail, mais cela implique également une gestion des modules installés et des environnements de développement,
\item création d'une interface en ligne de commande, suivant le cahier des charges du projet,
\item création et publication d'un package, pour lequel il a fallu gérer la problématique des chemins d'accès, 
\item rendre une application portable, en modifiant le code en fonction du système d'exploitation
\item création de machines virtuelles pour effectuer des tests sur différents systèmes d'exploitation, et création d'un environnement de test sur ces machines virtuelles
\item tests complets du package (unitaires, ... test pylint, module unittest,
\item la construction de ce package a nécessité de comprendre le fonctionnement de termes clés en bio-informatique afin de pouvoir travailler dans ce cadre métier particulier. Ceci a conduit à une synthèse de l'état de l'art fortement orientée vers la biologie et plus particulièrement le CRISPR.
\end{itemize}

Il faut assurément se confronter au moins une fois à ces compétences pratiques utiles pour bien en appréhender les difficultés.

Nous allons voir en détail dans ce rapport les différentes étapes suivies.



% PREALABLE -------------------------
\section{Remarque préalable}

Toutes les explications données dans ce rapport de stage ne concernent que les plateformes Linux. Celles-ci doivent être configurées pour exécuter par défaut une version récente de Python 3 (supérieure ou égale à 3.7) et une version de pip compatible avec Python 3.

Définissons par ailleurs le vocabulaire que nous allons utiliser dans ce rapport de stage :
\begin{itemize}
\item \index{module}module : un fichier contenant du code Python,
\item package : un répertoire contenant des modules Python,
\item \index{distribution}distribution : une archive de modules ou packages (au format tar, whl, ...)
\end{itemize}




% ETAT DE L'ART -------------------------------------
\chapter{Etat de l'art}


% OUT OF AFRICA MIGRATION ========================================================

\section{Evolution de la branche humaine de la tuberculose}

% Diversité génétique de la tuberculose

\subsection{Diversité génétique de la tuberculose}

Une bactérie survit d'autant mieux qu'elle est capable de s'adapter à son environnement au travers de mutations génétiques. Le polymorphisme génétique est à l'origine de la diversité génétique et correspond, dans le cas de notre étude, à des variations de séquences d'ADN entre différentes souches de \textit{M. tuberculosis}. Ces variations sont dues à des mutations successives au cours de l'évolution de la bactérie, et elles permettent l'analyse phylogénique de \textit{M. tuberculosis}. Il existe plusieurs formes de polymorphisme, le polymorphisme chromosomique lié à un changement du nombre de chromosomes ou de leurs structures, le polymorphisme d'insertion, de délétion et d'inversion qui provoquent un changement spécifique de certaines séquences du génome, et le polymorphisme nucléotidique SNP \textit{Single Nucleotide Polymorphism} lié au changement d'une seule paire de bases\footnote{\index{Paire de bases}\textbf{Paire de bases} : appariement de 2 bases nucléiques situées sur 2 brins complémentaires d'ADN, reliées par des ponts d'hydrogène.} du génome de \textit{M. tuberculosis}. Nous allons détailler plus particulièrement ce dernier cas.

Certaines mutations n'ont aucun impact évolutif sur \textit{M. tuberculosis}. En revanche, des changements fonctionnels peuvent avoir lieu lorsque ces mutations entraînent des modifications d'acides aminés dans les régions codantes, cela peut-être le cas lors d'une adaptation à l'environnement ou lors d'une nouvelle forme de résistance aux antibiotiques. Les SNPs synonymes ne changent pas la séquence de protéine, ainsi la substitution d'un codon\footnote{\index{Codon}\textbf{Codon} : ensemble composé de trois nucléotides consécutifs spécifiant l'incorporation d'un acide aminé déterminé. Le code génétique est ainsi lu trois nucléotides par trois nucléotides.} par un autre codon peut engendrer le même acide aminé. Au contraire, les SNPs non-synonymes changent la séquence de protéine, et engendrent donc l'incorporation d'un acide aminé différent. Chez \textit{M. tuberculosis}, les SNPs sont peu sujets à des phénomènes d'homoplasie\footnote{\index{Homoplasie}\textbf{Homoplasie} : similitude de caractères chez différentes espèces, qui ne provient pas d'un ancêtre commun, mais peut par exemple provenir d'une adaptation à l'environnement. Diffère de l'homologie qui est une similitude de caractères observée chez deux espèces différentes, provenant de l'héritage d'un ancêtre commun.}(seuls 1,1 \% des SNPs sont homoplasiques), ce qui suggère que la structure de \textit{M. tuberculosis} favorise les clonages plutôt que les recombinaisons entre branches. Pour de tels organismes clonaux, l'identification de mutations homoplasiques est un excellent moyen de déterminer les différentes souches bactériennes, et ainsi de procéder à des études phylogéniques\footnote{\index{Phylogénie}\textbf{Phylogénie} : étude des liens entre espèces apparentées, permettant de retracer les principales étapes de l'évolution des organismes depuis un ancêtre commun.} et de classification.

% Co-évolution de la tuberculose avec l'homme moderne

\subsection{Co-évolution de la tuberculose avec l'homme moderne}

Le développement des maladies s'adapte à la densité de population concernée. En effet, auprès d'une foule dense, les infections se répandent plus largement et deviennent plus virulentes, alors qu'auprès d'une population moins importante, elles ont une croissance plus faible, laissant parfois place à des périodes où les infections restent latentes.

Une période charnière dans l'histoire de l'humanité est la transition démographique du Néolithique, qui a vu il y a 10 000 ans, suite à l'apparition de l'agriculture et de l'élevage, un accroissement de la population, favorisant la naissance de nombreuses maladies. Les maladies humaines plus anciennes se développaient auprès de populations moins denses et produisaient des phases chroniques de latence et de réactivation permettant aux populations infectées de survivre.

Nous allons voir que la tuberculose conjugue ces deux modèles de maladie.

% The global diversity of human-adapted MTBC

L'étude phylogénique de Comas et al.\cite{comas} se base exclusivement sur l'étude du génome\footnote{\index{Génome}\textbf{Génome} : ensemble de l'information génétique d'un organisme. Par extension, le génome se réfère aussi au support physique de cette information génétique, la macromolécule d'ADN. L'annotation des gènes est le processus permettant d'identifier l'emplacement des gènes dans l'ADN, de déterminer leurs fonctions et leurs possibles interactions.} complet de toutes les lignées connues de \textit{M. tuberculosis} en utilisant les SNPs comme marqueurs pour construire les relations entre les différentes branches. Les résultats obtenus rejoignent de précédentes études effectuées à partir d'autres marqueurs, et confirment l'existence de sept principales lignées de tuberculose. On remarque en particulier que plusieurs branches d'origine animale se sont regroupées avec la lignée 6 d'Afrique de l'Ouest, et que les lignées modernes 2 d'Asie de l'Est, 3 d'Asie Centrale et 4 d'Europe ont des origines proches. 

% African origin and co-divergence of MTBC with modern humans

L'analyse phylogénique de Comas et al. corrobore la conjecture selon laquelle la tuberculose est originaire d'Afrique. Par ailleurs, s'appuyant sur les origines africaines de l'espèce humaine, cette étude cherche également à déterminer l'ancienneté de l'association entre la tuberculose et son hôte humain. Pour cela, l'analyse des divergences des génomes de la tuberculose est comparée à celle d'une arborescence génétique déjà établie à partir de mitochondries\footnote{\index{Mitochondrie}\textbf{Mitochondrie} : centrale énergétique des cellules qui contribue à la production d'ATP.} de l'être humain. 

% Age of the association of MTBC and humans

Les similitudes relevées montrent que la tuberculose a infecté les premiers hommes d'Afrique. Pour aller plus loin, l'étude de Comas et al. a tenu compte de trois dates importantes dans l'évolution biologique de l'être humain qui ont été reportées sur l'analyse phylogénique de \textit{M. tuberculosis} des lignées 5 et 6 d'Afrique de l'Ouest : l'émergence de l'homo sapiens correspondant au MTBC-185\footnote{\index{MTBC}\textbf{MTBC} : Mycobacterium Tuberculosis Complex.}, l'émergence de l'haplogroupe\footnote{\index{Haplogroupe}\textbf{Haplogroupe} : groupe possédant les mêmes caractères génétiques et partageant un ancêtre commun suivant une mutation SNP.} mitochondrial de la lignée 3 chez l'homme correspondant au MTBC-70, et le début de la transition démographique du Néolithique correspondant au MTBC-10.

La branche MTBC-185 suggère l'apparition de mutations à partir de lignées africaines il y a 174 000 ans, c'est à dire que la dispersion de la tuberculose précèderait celle de l'homo sapiens.

La branche MTBC-70 révèle des corrélations avec l'histoire de l'humanité telle qu'elle a pu être décrite par l'archéologie, en montrant l'apparition des sept différentes lignées de tuberculose :

- il y a 73 000 ans, apparition des lignées 5 et 6 correspondant à une première migration humaine importante vers l'Afrique de l'Ouest,\\
- il y a 67 000 ans, apparition de la lignée 1 correspondant à une migration humaine importante autour de l'Océan Indien,\\
- il y a 64 000 ans, apparition de la lignée 7 concernant une population qui est restée en Afrique ou est revenue en Afrique après une première migration,\\
- il y a 46 000 ans, apparition de la lignée 4 correspondant à une migration humaine importante vers l'Europe,\\
- il y a 42 000 ans, apparition des lignées 2 et 3 correspondant à une migration humaine importante vers l'Asie de l'Est et l'Asie Centrale. 

\begin{figure}[h!]
\centering
\includegraphics[scale=0.7]{worldlignee.png}
\caption{Phylogénie du génome complet de MTBC, d'après\\ \textit{Out-of-Africa migration and Neolithic coexpansion of Mycobacterium\\tuberculosis with modern humans}}
\end{figure}

% Neolithic co-expansion of MTBC and humans

Dans tous les cas, la tuberculose aurait infecté l'espèce humaine et évolué conjointement avec elle depuis 70 000 ans, mais son apparition serait antérieure à la transition démographique du Néolithique.

La base de données de tuberculose étudiée de façon probabiliste par Comas et al.\cite{comas} montre que le Néolithique a fortement contribué à l'expansion de la maladie il y a 10 000 ans grâce à l'augmentation de la densité de population et à la probabilité de co-infection avec d'autres maladies également dépendantes de la densité de population. La possibilité pour la tuberculose de muter d'une variété animale vers une variété humaine n'est en revanche pas retenue par Comas et al. En effet, l'analyse phylogénique de la tuberculose montre que les branches humaines ont divergé des branches animales avant le Néolithique.

Le Néolithique n'était pas la seule période où l'augmentation de la population fut importante, toutefois la concentration de population qui s'en est suivie a permis l'apparition, auprès de la tuberculose, de caractères fortement dépendants de la densité de population qu'elle affecte. Le Néolithique a donc marqué un tournant dans l'histoire de la tuberculose, qui a alors commencé à conjuguer les deux principaux modèles de maladie, d'une part dépendant de la densité de population et d'autre part s'apparentant à une infection chronique. En effet, le mode de transmission aérosol de la tuberculose s'est parfaitement adapté aux foules, et elle a montré à travers les âges des périodes de latence et de réactivation.

% The evolutionary history of MTBC at a regional scale
% Conclusion

Il faut donc considérer que la co-existence de la tuberculose avec l'espèce humaine depuis des milliers d'années a conduit la maladie à s'adapter aux changements du génome humain et inversement. Les prochaines études sur la tuberculose devraient donc se concentrer sur des génomes complets de la tuberculose et de l'être humain choisis en rapport à leurs associations.

En particulier, la tuberculose a dû s'adapter aux autres infections ayant touché l'espèce humaine, avec plus ou moins de succès. Dans cet ordre d'idée, une étude récente de Perry S. et al.\cite{perry1, perry2} suggère que l'infection d'un organisme par \textit{Helicobacter Pylori} pourrait protéger de la tuberculose sous sa forme active. A contrario, nous ne savons pas si la tuberculose latente pourrait protéger contre les ulcères et les cancers de l'estomac causés par \textit{Helicobacter Pylori}.

\begin{figure}
\centering
\includegraphics[scale=0.5]{world.png}
\caption{Distribution géographique des lignées 1 à 6, d'après \textit{Lineage\\ specific histories of Mycobacterium tuberculosis dispersal in Africa and Eurasia}}
\end{figure}

%  GLOBAL EXPANSION OF MTBC LINEAGE 4 =============================================

\section{Le développement de souches résistantes aux antibiotiques}

\subsection{L'expansion de la lignée 4 de \textit{M. tuberculosis}}

% global diversity of L4
% phylogeographic inference

La lignée 4 de \textit{M. tuberculosis} est la plus répandue de par le monde et pour cette raison a fait l'objet de nombreuses publications. Brynildsrud O.B. et al.\cite{brynildsrud} utilisent des méthodes d'analyse discrète et une approche bayésienne\footnote{\index{Approche bayésienne}\textbf{Approche bayésienne} : méthode probabiliste basée sur le calcul des probabilités postérieures des arbres phylogéniques par la combinaison d'une probabilité antérieure avec la fonction de vraisemblance} en phylogénie moléculaire pour obtenir de manière formelle l'évolution phylogéographique de la lignée 4 de \textit{M. tuberculosis}. Ils estiment que le plus récent ancêtre commun de la lignée 4 est apparu en Europe en 1096 après JC. Si on considère l'Europe en tant que continent au sens large, cela ne contredit pas les résultats de O'Neil M.B. et al.\cite{oneil} qui estiment l'origine de la lignée 4 autour de la méditerranée.

% Patterns of L4 migration through time

L'analyse phylogéographique de Brynildsrud O.B. suggère que les premières vagues de migration de la lignée 4 hors d'Europe se sont déroulées au début du 13ème siècle vers l'Asie du Sud-Est. Il est également possible d'établir une correspondance entre la structure des isolats\footnote{\index{Isolat}\textbf{Isolat} : fragment d'organisme qu'on a isolé à des fins d'examen histo-pathologiques ou pour être cultivé in vitro.} Vietnamiens et l'époque de l'expansion coloniale française en Indochine au 19ème siècle.

Les vagues suivantes de migration de la lignée 4 se sont dirigées vers l'Afrique de l'Ouest au 15ème siècle, puis vers Afrique de l'Est et du Sud au 17ème siècle. Les échanges continus avec le Portugal dès le 15ème siècle ont favorisé la dispersion de la maladie, ce qui a été renforcé plus tard par la colonisation française de l'Afrique de l'Ouest.  Ces échanges avec les populations européennes ont prévalu à une transmission locale de la tuberculose jusqu'au 19ème siècle. 

La transmission de la maladie en Amérique date, elle aussi, du 15ème siècle avec la colonisation du continent, mais il faudra attendre le 17ème siècle pour voir l'explosion de la maladie en Amérique du Sud. Ce retard dans l'évolution de la maladie par rapport à la branche africaine peut s'expliquer par le taux de mortalité élevé des populations aborigènes au contact des européens.

La première migration interne de la maladie en Afrique date de l'Empire Zulu au 19ème siècle et se dirigeait vers le Nord et l'Est africain.

Ainsi, Brynildsrud O.B. et al. montrent que la dispersion de la lignée 4 est essentiellement liée à l'expansion coloniale européenne en Afrique et en Amérique entre le 17ème et le 19ème siècle.

% antibiotiques

\subsection{L'adaptation de la lignée 4 pour devenir résistante aux antibiotiques}

Nous avons déjà vu que la tuberculose a su s'adapter à l'évolution géographique de l'humanité en suivant les différentes migrations humaines pour créer de nouvelles lignées ou de nouvelles souches. Il apparaît que la tuberculose est également capable de suivre l'évolution médicale de l'humanité. L'étude de Brynildsrud O.B. et al.\cite{brynildsrud} constate chez \textit{M. tuberculosis} l'émergence croissante d'une résistance à de multiples antibiotiques entre 1960 et 2000 au travers de la phylogénie de la lignée 4.

Des mutations spontanées dans le génome de la tuberculose peuvent altérer les protéines qui sont la cible des médicaments, ce qui rend les bactéries résistantes à ces médicaments. Prenons comme exemple une mutation du gène rpoB de \textit{M. tuberculosis}, qui code pour la sous-unité $\beta$\footnote{\index{Sous-unité $\beta$}\textbf{Sous-unité $\beta$} : élément de l'ARN polymérase des bactéries qui est composé de la structure suivante $\alpha_2 \beta \beta' \omega$} de l'ARN polymérase\footnote{\index{ARN polymérase}\textbf{ARN polymérase} : complexe enzymatique responsable de la synthèse de l'ARN à partir d'ADN.} de la bactérie. Dans la tuberculose non résistante, la rifampicine se lie à cette sous-unité $\beta$ et perturbe l'élongation de la transcription de l'ARN. La mutation dans le gène rpoB modifie la séquence des acides aminés et donc de la sous-unité $\beta$. Dans ce cas, la rifampicine ne peut plus se lier à la sous-unité $\beta$ de l'ARN et empêcher la transcription. La bactérie est devenue résistante. C'est bien le cas de la tuberculose, qui est considérée aujourd'hui comme une maladie résistante aux antibiotiques. 

Une souche de \textit{M. tuberculosis} est appelée MDR-TB \textit{Multi-Drug-Resistant Tuberculosis} si elle est résistante au deux anti-tuberculeux de première intention les plus puissants, l'isoniazide et le rifampicine. Dans ce cas, certaines régions du génome de \textit{M. tuberculosis} sont impliquées dans la résistance à plus d'un médicament. La découverte de nouvelles cibles moléculaires s'avère essentielle pour lutter contre ce développement de la résistance chez \textit{M. tuberculosis}. Une souche de \textit{M. tuberculosis} est appelée XDR-TB si elle est de surcroît résistante aux anti-tuberculeux de seconde intention tels que le fluoroquinolone et l'aminoglycoside.

\begin{figure}[h!]
\centering
\includegraphics[scale=0.6]{amr.png}
\caption{Transmission de la résistance ces dernières années à l'échelle mondiale, d'après\\ \textit{Global expansion of Mycobacterium tuberculosis lineage 4 shaped by colonial migration and local\\ adaptation}. FLQ=fluoroquinolone, INH=isoniazide, KAN=aminoglycoside, RIF=rifampicine}
\end{figure}

Les causes de la résistance de \textit{M. tuberculosis} aux antibiotiques sont multiples, mais il s'agit principalement de l'utilisation inappropriée ou incorrecte d'antibiotiques, et de l'interruption précoce des traitements. Dans ce cas, les souches résistantes se transmettent génétiquement de générations en générations. Toutefois, ces souches résistantes de \textit{M. tuberculosis} peuvent aussi se transmettre directement à une personne saine, qui dans ce cas, se retrouve infectée avec une souche MDR-TB sans avoir pris de traitement inapproprié contre la tuberculose.

Brynildsrud O.B. et al. étudient également le gène lldD2 impliqué dans la réplication de \textit{M. tuberculosis} au sein des macrophages\footnote{\index{Macrophage}\textbf{Macrophage} : cellule appartenant aux globules blancs qui infiltre les tissus et est capable de phagocytose.} humains. Ils identifient au niveau des codons 3 et 253 la présence de nombreux promoteurs\footnote{\index{Promoteur}\textbf{Promoteur} : région de l'ADN située à proximité d'un gène et indispensable à la transcription de l'ADN.} et mutations non-synonymes qui ont évolué indépendamment.

Une recherche au sein d'une base de données recouvrant les lignées 1 à 6 a révélé que la mutation du codon 3 a émergé indépendamment dans les lignées 1, 2 et 4, alors que la mutation du codon 253 est apparue à plusieurs reprises dans la lignée 4 et est présente dans pratiquement tous les isolats de la lignée 2. Brynildsrud O.B. et al. constatent que les mutations de lldD2 ont commencé à apparaître bien avant l'utilisation des antibiotiques sur tous les continents. Ceci suppose une adaptation locale de \textit{M. tuberculosis} à de profonds changements chez l'hôte humain, qui s'est opérée en parallèle sur les différents continents. Par ailleurs, les souches hébergeant des mutations du promoteur lldD2 présentent un avantage significatif en terme de transmissibilité.

Il ne fait aucun doute que des souches MDR-TB peuvent traverser les frontières, comme cela a déjà été observé avec la lignée 2 entre l'Europe de l'Est et l'Europe de l'Ouest. Toutefois, le jeune âge relatif des souches résistantes pourrait expliquer le manque de migrations observées de ces souches. Brynildsrud O.B. et al. démontrent que, d'un point de vue mondial, la migration humaine a joué un rôle négligeable dans l'élaboration des modèles de résistance aux antimicrobiens. En effet, la migration des souches résistantes s'est avérée marginale. Il s'agit plutôt d'un phénomène local. La restriction géographique de souches résistantes suggère même de lutter contre ce type de mutation de \textit{M. tuberculosis} de façon nationale plutôt que de recourir à une politique globale de traitement antibiotique.

% SPOLPRED ==========================================================

\section{Le locus CRISPR-Cas}

\subsection{Quelques caractéristiques du génome de \textit{M. tuberculosis}}

La souche H37Rv de \textit{M. tuberculosis} est la souche de tuberculose la plus étudiée en laboratoire, depuis sa découverte en 1905. Elle sert aujourd'hui de référence pour le séquençage et l'annotation du génome de \textit{M. tuberculosis}. Constitué d'environ 4 millions de paires de base et 3959 gènes, ce génome se caractérise par un taux élevé de guanine G et de cytosine C (65,6\%), et un codon GTG qui sert de codon d'initiation dans 35\% des gènes. 

Parmi les marqueurs génétiques utilisés pour des études phylogéniques ou d'épidémiologie moléculaire, on retrouve les SNPs, les loci CRISPR, les MIRU\footnote{\index{Marqueur MIRU}\textbf{Marqueur MIRU Mycobacterial Interspaced Repetitive Units} : séquences nucléotidiques courtes répétitives en tandem entrecoupées de mycobactéries. La méthode MIRU actuellement utilisée sur \textit{M. tuberculosis} est composée de 12 loci MIRU différents. Un mirutype est un modèle à 12 chiffres représentant le nombre de répétitions de chacun de ces 12 loci spécifiques.}, et les VNTR\footnote{\index{Marqueur VNTR}\textbf{Marqueur VNTR Variable Number of Tandem DNA Repeats} : séquences nucléotidiques courtes en tandem à nombre variable. Cinq répétitions en tandem exactes ( locus ETR) sont utilisées pour l'analyse VNTR du complexe \textit{M. tuberculosis}.}. L'association des résultats obtenus par ces marqueurs génère un profil allélique\footnote{\index{Allèle}\textbf{Allèle} : version variable d'un même gène.} utile pour l'étude du complexe \textit{M. tuberculosis}. La base de données mondiale de marqueurs moléculaires de la tuberculose SITVIT\footnote{\index{Base de données SITVIT}\textbf{Base de données SITVIT} : base de données de l'Institut Pasteur de Guadeloupe consultable en ligne \url{http://www.pasteur-guadeloupe.fr:8081/SITVIT_ONLINE/query}, permettant n'analyser des data liées au MTBC. Elle comprend les spoligotypes de \textit{M. tuberculosis}, ainsi que les marqueurs utilisés pour les détecter MIRU12, VNTR, SIT, MIT, VIT, les différentes branches de MTBC, les pays d'origine et l'année de découverte.} présentée par Demay C. et al.\cite{demay} contient les génotypes de \textit{M. tuberculosis} obtenus à partir des marqueurs moléculaires MIRU et VNTR.

% Le locus CRISPR Cas

\subsection{Description du locus CRISPR-Cas}

\begin{figure}[h!]
\centering
\includegraphics[scale=0.6]{crispr.png}
\caption{Structure du locus CRISPR-Cas, d'après\\ \url{https://www.sinobiological.com/crispr-locus.html}}
\end{figure}

Le locus CRISPR \textit{Clustered Regularly Interspaced Short Palindromic Repeats} est une famille de séquences répétées (DR pour \textit{Direct Repeat}) dans l'ADN formant un palindrome, qui se trouve à l'état naturel chez 40\% des bactéries (dont le \textit{M. tuberculosis}) et la plupart des archées. CRISPR est héritable par transmission aux cellules filles et se conserve donc pour une même espèce. Chez \textit{M. tuberculosis}, chaque série de répétitions contient 36 bp\footnote{\textbf{bp} : une paire de base.}; les répétitions étant régulièrement espacées par des espaceurs de 34 à 41 bp. A l'heure actuelle, 104 espaceurs ont été identifiés dans toutes les souches de \textit{M. tuberculosis}. Les loci CRISPR sont généralement adjacents aux gènes Cas, dont ils sont séparés par une séquence de 300 à 500 bp, appelée leader qui contrôle à la fois l'acquisition de l'ADN viral par les espaceurs et la fabrication des protéines. Les gènes Cas produisent des protéines aux fonctionnalités multiples et notamment les enzymes\footnote{\index{Enzyme de restriction}\textbf{Enzyme de restriction} : protéine capable de couper un fragment d'ADN au niveau d'une séquence de nucléotides caractéristique appelée site de restriction. Chaque enzyme de restriction reconnaît ainsi un site spécifique.} capables de couper l'ADN en vue de sa réparation.

Ces séquences CRISPR incorporent dans les espaceurs des fragments d'ADN de bactériophages qui ont déjà infecté la bactérie, et sont stockés pour détecter et détruire l'ADN de bactériophages similaires en cas de nouvelle infection. Par conséquent, CRISPR-Cas est un système immunitaire naturel utilisé par les bactéries pour se protéger des infections virales. 

% Fonctionnement du système CRISPR-Cas 

\subsection{Fonctionnement du système CRISPR-Cas}

Les systèmes CRISPR-Cas sont de trois types et utilisent les différents gènes Cas pour intégrer des fragments de gènes étrangers dans les espaceurs de CRISPR. Par exemple, dans le cas d'une bactérie qui détecte la présence d'ADN ou d'ARN d'un virus, elle produit une enzyme nucléase appelée Cas9 capable de couper l'ADN viral, puis une séquence d'ARN CRISPR notée crARN correspondant à celle de l'ADN du virus et servant de guide ARN, et finalement une séquence d'ARN traceur notée trARN. Lorsque trARN trouve sa cible parmi le génome du virus, Cas9 sectionne l'ADN viral puis en incorpore un fragment dans un espaceur du génome de la bactérie, conservant ainsi en mémoire une trace de ce virus en vue d'une éventuelle infection future. Les espaceurs servent donc de banque de mémoire en conservant l'ADN des virus qui ont attaqué la bactérie. Cette fonctionnalité va être exploitée de différentes manières par les biologistes.

La technologie CRISPR-Cas9, s'inspirant du système du même nom, a d'abord été utilisée pour typer les souches bactériennes, suivant une technique appelée spoligotypage. CRISPR-Cas9 est actuellement principalement employé comme ciseau moléculaire afin d'éditer le génome et d'introduire localement des modifications génétiques.

% Spoligotyping

\section{Le spoligotypage}

La région DR du locus CRISPR-Cas présente un niveau de polymorphisme suffisant pour pouvoir classer phylogéographiquement les souches de \textit{M. tuberculosis}. Le polymorphisme entre les différentes souches résulte des variations et de l'identité des espaceurs. C'est ce polymorphisme qui est exploité en 1997 par Kamerbeek et al. et expliqué dans \cite{kamerbeek} comme technique de génotypage spécifique de \textit{M. tuberculosis}. Le \textit{Spacer Oligonucleotide Typing}, repose sur la détection de séquences répétitives trouvées entre les gènes d'un agent infectieux au sein d'un locus CRISPR-Cas. Pour ce faire, la région DR d'un isolat à tester subit un traitement par amplification PCR\footnote{\index{PCR}\textbf{PCR Polymerase Chain Reaction} : méthode de réaction en chaîne utilisant un polymère pour dupliquer en grand nombre une séquence d'ADN spécifique. La méthode PCR repose sur le cycle thermique, qui expose les séquences à des cycles répétés de chauffage et de refroidissement pour permettre différentes réactions dépendantes de la température comme la fusion de l'ADN et la réplication de l'ADN par les enzymes. La méthode PCR utilise deux agents principaux : les polymères d'ADN i.e. des macromolécules répétant un même motif structural d'ADN et les amorces de séquençage.} ou celui d'une puce à ADN\footnote{\index{Puce à ADN}\textbf{Puce à ADN} : ensemble de molécules d'ADN fixées sur une petite surface solide permettant de mesurer le niveau d'expression d'un grand nombre de gènes simultanément, ou de déterminer le génotype de plusieurs régions d'un génome.}, pour dévoiler un motif de taches correspondant aux espaceurs. 

\begin{figure}[h!]
\centering
\includegraphics[scale=0.4]{spoligo.png}
\caption{Les différentes étapes du spoligotypage d'après \textit{Etudes descriptive, épidémiologique,\\ moléculaire et spatiale des souches Mycobacterium tuberculosis circulant à Antananarivo, Madagascar}}
\end{figure}

La comparaison de ces motifs permet la différentiation des souches. Quarante-trois espaceurs les plus polymorphes ont été utilisés pour le typage des mycobactéries suivant Kamerbeek et al. La classification classique de MTBC utilise donc un groupe de 43 bits représentant la présence ou l'absence d'espaceurs dans le locus CRISPR, qu'on appelle spoligotype. Des études pour augmenter le niveau de discrimination du spoligotypage ont été faites en 2010 utilisant 68 espaceurs. A l'heure actuelle l'équipe AND de l'université de Franche Comté utilise 98 espaceurs pour ce génotypage.

\begin{figure}[h!]
\centering
\includegraphics[scale=0.7]{spacer.png}
\caption{Espaceurs connus chez MTBC, d'après \textit{Etudes descriptive, épidémiologique, moléculaire\\ et spatiale des souches Mycobacterium tuberculosis circulant à Antananarivo, Madagascar}}
\end{figure}

La technique ne nécessite pas une importante quantité d'ADN car elle est basée sur une amplification de la région DR par PCR. Les spoligotypes ainsi obtenus peuvent être partagées entre laboratoires et corroborent les résultats recueillis à partir d'autres marqueurs génétiques. Ces données numériques permettent de bien différencier les souches de \textit{M. tuberculosis} et sont de moindre coût comparativement à d'autres méthodes. Cependant, le spoligotypage éprouve des difficultés à bien différencier les souches au sein de grandes familles de \textit{M. tuberculosis} telles que la lignée 2 par exemple.

Jusqu'à présent, le spoligotypage a permis de fournir une image globale de la diversité des souches de \textit{M. tuberculosis}.

Une nouvelle technologie permettant de combiner le spoligotypage avec des tests moléculaires de sensibilité aux anti-tuberculeux, appelée spoligoriftypage, a été développée pour aboutir à la version TB-SPRINT qui a été décrite en 2013 par Gomgnimbou et al. dans leur article \cite{gomgnimbou}. Elle consiste au typage tuberculose-spoligo-rifampicine-isoniazide fonctionnant sur des systèmes à base de microbilles, à partir notamment de 43 espaceurs, 11 SNPs présents sur rpoB aux positions 516, 526 et 531. Cette nouvelle génération de spoligotypage fournit donc, en plus des données classiques de génotypage, une prédiction basée sur la mutation des profils de résistance aux médicaments.

% Normalisation

\subsection{Vers une normalisation des spoligotypes}

Au début du spoligotypage, il n'existait pas de norme pour décrire les motifs formés par les espaceurs ou simplement les numéroter. Chaque laboratoire utilisait son propre système de numérotation accompagné d'un schéma descriptif du motif. Ce manque de normalisation entravait les possibilités de comparaison des résultats obtenus et le développement d'une vision mondiale de l'évolution de \textit{M. tuberculosis}. Une méthode standardisée de description des spoligotypes a été proposée en 2001 par Dale JW dans son article \cite{dale}. 

Tout d'abord, une base de données centralisée regroupant tous les motifs connus et de leurs numérotations associées existe au RIVM Rijksinstituut voor Volksgezondheid en Milieuhygiene, Bilthoven, Netherlands. Elle peut être consultée au \url{http://www.caontb.rivm.nl}. A partir de 2001, les nouveaux motifs doivent prendre un unique format de numérotation pour être répertoriés dans cette base de données. Toutefois, cela nécessite l'interrogation systématique de la base de données et la comparaison avec les éléments déjà existants pour chaque nouveau spoligotype. Pour éviter cette perte de temps, de nombreux laboratoires utilisent des systèmes rationnels avec des codes descriptifs assignés à chaque isolat. 

Dale JW et al.\cite{dale} proposent d'utiliser exclusivement un système rationnel octal ou hexadécimal, sachant qu'il est aisé de passer de l'un à l'autre et qu'il est également facile de retrouver l'état initial binaire. Ainsi, les motifs de spoligotype comprenant 43 bits seraient réduits dans le système octal en 14 groupes de 3 bits auquel s'ajouterait un unique bit, ce qui donnerait finalement un ensemble de 15 chiffres en écriture octale. En ce qui concerne le système hexadécimal, les motifs de 43 bits seraient réduits en 6 groupes de 8 bits avec un dernier groupe ne comprenant que 3 bits, soit 6 groupes de 2 chiffres hexadécimaux. Notons qu'un bit symbolise dans ce cas la présence ou l'absence d'une espaceur dans le locus étudié.

\begin{figure}[h!]
\centering
\includegraphics[scale=0.6]{hexa.png}
\caption{Exemple de système rationnel octal et hexadécimal, d'après\\ \url{https://www.mbovis.org/spoligotype-nomenclature.php}}
\end{figure}

Le site Mbovis.org, \url{https://www.mbovis.org/database.php}, bien que dédié aux souches animales de MTBC, fournit une application pratique permettant de transformer rapidement les spoligotypes binaires en système octal ou hexadécimal.

% Spolpred et SpoTyping

\subsection{Quel outil informatique pour le spoligotypage ?}

Les technologies PCR de génotypage utilisent toujours différents marqueurs tels que les SNPs pour obtenir en laboratoire des résultats fiables. Des logiciels informatiques de prédiction du génotype ont également fait leur apparition pour optimiser les coûts et le gain de temps. Ils offrent un outil de comparaison des résultats obtenus expérimentalement et in silico.

SpolPred est un logiciel de prédiction rapide et précis des spoligotypes de \textit{M. tuberculosis} à partir de séquences génomiques courtes appelées reads\footnote{\index{Reads}\textbf{Reads} : mélange de courtes séquences oligonocléotidiques de 20 à 200 bp générées par des séquenceurs}. Cet outil développé par Coll F. et al. fonctionne efficacement avec des reads provenant de plateformes telles que Illumina GAII ou HiSeq. SpolPred utilise des fichiers de séquences de reads simples ou par paires au format FASTQ, afin de produire une prédiction de spoligotype au format octal, qui est ensuite comparée au spoligotype correspondant dans la base SITVIT.

\begin{figure}[h!]
\centering
\includegraphics[scale=0.44]{spol.png}
\caption{Exemple de recherche effectuée sur SITVIT2 à partir du spoligotype 777777777720771 dont le résultat est exploitable au format Excel}
\end{figure}

Dans leur étude \cite{coll}, Coll F. et al. montrent en 2012 l'utilité de SpolPred en comparant les spoligotypes obtenus par le logiciel avec les résultats de laboratoire. Ils dévoilent ainsi les limites de la méthode expérimentale qui a répertorié cinq faux spoligotypes, alors que SpolPred a su éviter ces erreurs de classification du génotype. Par ailleurs, il apparaît que SpolPred offre plus de rapidité avec des résultats pratiquement identiques à ceux obtenus avec la méthode bio-informatique par assemblage. Cette dernière, développée en 2008 à l'aide du logiciel Velvet, consiste à fusionner des fragments d'ADN issus d'une plus longue séquence afin d'en reconstruire la séquence originale.

Toutefois, d'après l'étude de Xia et al.\cite{xia}, la précision de SpolPred est fortement réduite lorsque les reads n'ont pas une taille uniforme, comme par exemple lorsqu'ils proviennent de séquençages Ion Torrent ou de la plateforme de diagnostique clinique Illumina MiSeq. Ainsi, lorsque les reads ne sont pas uniformes, la précision des résultats dépend fortement de leurs tailles et donc du choix initial fait par l'opérateur. Par ailleurs, SpolPred demande à l'utilisateur de spécifier la direction de lecture des reads, et le logiciel n'utilise donc qu'une partie des informations fournies par les reads.

Une problématique de SpolPred en 2020 est que le logiciel n'est plus disponible au téléchargement en ligne. En effet, une visite sur le site officiel \url{http://www.pathogenseq.org/spolpred}, fourni comme référence dans le document \cite{coll} de Coll F. et al., montre que le nom du domaine est à vendre. Preston M., qui a fait partie de l'équipe de recherche de Coll F. pour le développement de SpolPred, a bien créé un site proposant le téléchargement du logiciel \url{https://www.mybiosoftware.com/spolpred-predict-the-spoligotype-from-raw-sequence-reads.html}, mais le lien est inactif en janvier 2020.

Une alternative à SpolPred est SpoTyping présenté en 2016 dans l'article \cite{xia} de Xia et al. comme étant 20 à 40 fois plus rapide que SpolPred pour prédire avec précision des spoligotypes de \textit{M. tuberculosis} à partir de reads de taille uniforme ou variable. Par ailleurs, SpoTyping lit chaque read dans les deux directions en exploitant complètement les informations fournies. SpoTyping réduit la durée des recherches en intégrant l'algorithme BLAST\footnote{\index{BLAST}\textbf{BLAST Basic Local Alignment Search Tool} : logiciel basé sur l'algorithme du même nom qui détecte des régions similaires entre plusieurs séquences biologiques. Le programme compare les séquences de nucléotides aux séquences contenues dans la base de données BLAST pour fournir des résultats statistiquement significatifs.} dans ses calculs. Il compare les isolats testés avec ceux ayant le même spoligotype dans la base de données mondiale SITVIT, qui regroupe les données épidémiologiques\footnote{\index{Epidémiologie}\textbf{Epidémiologie} : discipline scientifique qui étudie les problèmes de santé dans les populations humaines, leur fréquence, leur géographie ainsi que les facteurs influents.} associées à des isolats de même spoligotype.

L'intérêt d'un outil tel que SpolPred ou Spotyping est qu'il est capable de combiner le spoligotypage avec d'autres méthodes telles que MIRU (unités répétitives entrecoupées de mycobactéries) et VNTR nombre variable de répétitions d'ADN en tandem) en utilisant la base de données SITVIT.

SpoTyping utilise des fichiers de séquences de reads simples ou par paires au format FASTQ et des fichiers de séquences complètes de génomes ou de contigs\footnote{\index{Contig}\textbf{Contig} : séquence génomique continue et ordonnée, générée par l'assemblage des clones d'une bibliothèque génomique qui se chevauchent.} assemblés au format FASTA. Les séquences de reads sont regroupées en une unique séquence continue au format FASTA pour être ensuite soumise à l'algorithme BLAST qui détecte les régions similaires. Finalement la base de données SITVIT permet d'identifier les isolats ayant le même spoligotype. SpoTyping est limité à une lecture de 250 Mbp au sein des séquences de reads testées, lors de l'utilisation du swift mode qui accélère le temps de traitement.

SpoTyping propose un rapport statistique permettant de résumer le rapprochement avec les spoligotypes trouvés dans la base de données SITVIT, ainsi qu'une estimation du nombre de correspondances positives pour chaque espaceur.

\begin{figure}[h!]
\centering
\includegraphics[scale=0.65]{spotyping.png}
\caption{Exemple de fonctionnement de SpoTyping, d'après \textit{SpoTyping:\\ fast and accurate in silico Mycobacterium spoligotyping from sequence reads}}
\end{figure}

D'après le repository \url{https://github.com/xiaeryu/SpoTyping-v2.0/blob/master/SpoTyping-v2.0-commandLine/SpoTyping-README.pdf}, les spécifications techniques de SpoTyping sont les suivantes :\\
- SpoTyping peut s'exécuter sur les principaux systèmes d'exploitation, contrairement à SpolPred qui utilise exclusivement Linux. Il se présente à la fois sous forme de script et sous forme d'application avec une interface graphique.\\
- SpoTyping est un logiciel open-source qui peut se télécharger gratuitement à l'adresse \url{https://github.com/xiaeryu/SpoTyping-v2.0}. SpoTyping nécessite l'utilisation de Python2.7 et BLAST.\\
- il est recommandé d'utiliser le swift mode paramétré par défaut si le débit de séquençage\footnote{\index{Séquençage du génome}\textbf{Séquençage du génome} : consiste, par des méthodes chimiques ou de biologie moléculaire, à déterminer l'ordre des nucléotides de l'ADN.} est inférieur à 135 Mbp. Pour les débits de séquençage inférieurs à 135 Mbp ou supérieurs à 1260 Mbp, les seuils doivent être réglés entre 0.018 et 0.1486 fois la profondeur de lecture estimée pour les hits sans erreur, et entre 0.018 et 0.1488 fois la profondeur de lecture estimée pour les hits tolérant une erreur. Notons que la profondeur de lecture est définie par le débit de séquençage divisé par 4 500 0000 qui correspond à l'estimation de la longueur d'un génome de \textit{M. tuberculosis}.

Le fichier obtenu propose une prédiction de spoligotype au format de code binaire et octal. Le fichier log obtenu contient le nombre de correspondances positives des résultats de BLAST pour chaque séquence d'espaceurs. Le fichier xls Excel obtenu fournit le résultat de la recherche de spoligotype auprès de la base de données SITVIT2\footnote{\index{Base de données SITVIT2}\textbf{Base de données SITVIT2} : mise à jour de la base de données SITVIT, consultable en ligne \url{http://www.pasteur-guadeloupe.fr:8081/SITVIT2/index.jsp}}.

L'étude de Iwai H. et al.\cite{iwai} envisage une autre possibilité de travail et montre l'intérêt d'une analyse de \textit{M. tuberculosis} à l'aide de serveurs, appelée CASTB, et notamment le spoligotypage. Le Webserver fournit une vue complète des données, mais les performances de chaque outil utilisé ne sont pas décrites dans l'article. Il est probable que le spoligotypage prenne plus de temps en passant par un serveur suite au problème de disponibilité des données et aux lenteurs de téléchargement de ces données. Il semblerait que SpoTyping, de par sa configuration locale, puisse fournir un résultat en une minute.

% Comparaison de spoligotypes

\subsection{Comparaison de spoligotypes}

Une fois les spoligotypes de différentes lignées obtenus, il est nécessaire de les comparer pour chercher à faire ressortir les points communs ou certains traits pouvant être liés à une mutation particulière. Il existe à l'heure actuelle un premier outil en ligne de comparaison du nom de SpolSimilaritySearch, accessible à l'adresse \url{http://www.pasteur-guadeloupe.fr:8081/SpolSimilaritySearch/index.jsp}, et présenté par Couvin D. et al.\cite{couvin}. SpolSimilaritySearch incorpore un algorithme de recherche de similitudes entre spoligotypes dans la base de données SITVIT2. Cet outil permet d'analyser les modèles de propagation et d'évolution de \textit{M. tuberculosis} en comparant des modèles de spoligotypes similaires, de distinguer les modèles répandus, confinés ou spécifiques, d'identifier les modèles ayant de grands blocs supprimés ou encore de fournir les modèles de distribution par pays pour chaque spoligotype interrogé.

Par exemple, si on sélectionne le spoligotype 777777777720771 appartenant à la lignée H3, et qu'on interroge la base SpolSimilaritySearch, on obtient les rapprochements suivants :

\begin{figure}[h!]
\centering
\includegraphics[scale=0.37]{spolsimilarity.png}
\caption{Recherche effectuée sur le site de SpolSimilaritySearch}
\end{figure}

Cet outil pourrait donc s'avérer utile pour commencer à chercher des liens entre les sept lignées de \textit{M. tuberculosis} et les spoligotypes de différentes souches.
Un tableau comparatif de différents spoligotypes en fonction des lignées de \textit{M. tuberculosis} pourrait ressembler à celui de la figure 11.

\begin{figure}[h!]
\centering
\includegraphics[scale=0.4]{comparaison.png}
\caption{Exemple comparatif de 26 spoligotypes correspondant à 4 lignées différentes de \textit{M. tuberculosis}, d'après \textit{Insight into genetic diversity of Mycobacterium tuberculosis in Kandy, Sri Lanka reveals predominance of the Euro-American lineage}}
\end{figure}
	


% LA NOTION DE PACKAGE ---------------------------
\chapter{La notion de package}



% COMPOSITION D'UN PACKAGE STANDARD ------------------
\section{Composition d'un package standard}

Un \index{package}package standard comporte obligatoirement un fichier \textbf{\_\_init\_\_.py} qui va définir la version du projet et le nom du module de lancement du programme (souvent \textbf{\_\_main\_\_.py}). Il est toutefois acceptable et parfois même recommandé de conserver un fichier \textbf{\_\_init\_\_.py} vide. Par ailleurs, chaque sous dossier vide ou contenant des modules Python devra également contenir un fichier \textbf{\_\_init\_\_.py}.

Les fichiers \textbf{setup.py}, \textbf{requirements.txt}, \textbf{LICENSE},  \textbf{README.md} et \textbf{MANIFEST.in} sont également nécessaires.  
\begin{itemize}
\item \textbf{setup.py} est le script de construction et configuration destiné au \textit{setuptools}. Il définit notamment le nom et la version du package, ainsi que les fichiers qu'il contient. Il sert également d'interface en ligne de commande relative aux différentes fonctionnalités du package. \textbf{setup.cfg} est un fichier d'initialisation qui contient les options par défaut des commandes du \textbf{setup.py}.
\item \textbf{requirements.txt} permet l'installation des dépendances à l'aide d'un unique fichier contenant un module à installer par ligne. Il nécessite l'instruction 
\texttt{  pip install -r requirements.txt}
pour commencer ces installations.
\item \textbf{LICENSE} définit les termes légaux de la distribution. De nombreux pays n'autorisent pas l'utilisation ou la distribution d'un package qui ne dispose pas de licence.
\item \textbf{README.md} décrit l'objectif du package, son installation, la nature de ses dépendances et les principales fonctionnalités.
\item \textbf{MANIFEST.in} permet d'inclure dans le package certains fichiers qui ne sont pas automatiquement intégrés. 
\end{itemize}

Il est important de regrouper l'ensemble des modules nécessaires au fonctionnement du package dans un répertoire portant le même nom que ce package, accompagné d'un fichier \textbf{\_\_init\_\_.py}, sinon l'archive et la distribution du package se construiront à vide. L'installation à partir de PyPI fonctionnera mais l'exécution du package restera inactive.

Avec la PEP-518\footnote{\index{PEP-518}\textbf{PEP-518:} specifying minimum build system requirements for Python projects}, le PyPA\footnote{\index{PyPA}\textbf{PyPA:} Python Packaging Authority} a proposé un nouveau standard au format \textit{.toml}, qui remplace les fichiers \textbf{setup.py}, \textbf{requirements.txt}, \textbf{setup.cfg} et \textbf{MANIFEST.in}. C'est ce nouveau standard qui est utilisé lors de la création d'un package avec \textit{Poetry}.

 Par ailleurs, les packages construits pour des systèmes Linux et MacOS nécessitent l'incorporation de fichiers \textbf{build.sh} et \textbf{meta.yaml} alors que les packages construits pour les systèmes Windows nécessitent l'incorporation des fichiers \textbf{bld.bat} et \textbf{meta.yaml}. Ces différents formats sont également incorporés dans un fichier \textbf{pyproject.toml}.



% QUELLE LICENCE CHOISIR ------------------
\section{Quelle licence choisir ?}
	
Trois \index{licence}licences retiennent notre attention. En voici les principales caractéristiques :
\begin{itemize}
\item	la licence MIT, courte et permissive, préserve exclusivement le copyright et les avis de licence. Toute modification ultérieure peut être distribuée suivant une licence différente et notamment utilisée à des fins personnelles ou commerciales, sans obligation de publication des codes source,
\item	la licence Apache (2.0) est également permissive et sensiblement similaire dans ses conditions à la licence MIT. Toutefois, elle requiert de préciser les modifications effectuées lors de nouvelles distributions,
\item	la licence GNU (GPL v3.0) préserve également le copyright et les avis de licence. Elle peut être utilisée à des fins personnelles et commerciales. Elle impose en outre, en cas de modification, la publication complète des codes et l'utilisation de la licence GNU pour les nouvelles distributions.
\end{itemize}

Dans le cadre de ce projet, aucune spécification restrictive n'étant requise, nous avons choisi la licence MIT qui est simple et peu contraignante.




% FONCTIONNEMENT D'UN PACKAGE
\section{Fonctionnement d'un package}

La bonne compréhension des chemins d'accès est au coeur du fonctionnement d'un package.

Un programme s'exécute dans un répertoire courant et accède aux différents fichiers support en utilisant un chemin relatif par rapport à ce répertoire ou encore en utilisant un chemin absolu. Les différentes dépendances sont importées en début de code, sans référence à un chemin d'accès car elles ont préalablement été installées dans l'environnement de développement que va utiliser l'interpréteur Python. Elles sont en plus installées dans l'environnement de développement intégré dans le cas où on utilise un tel outil.

Un package en revanche, n'est pas défini par rapport au répertoire courant. Il va s'installer à un emplacement spécifique défini par le système d'exploitation. Par défaut cet emplacement est \textbf{~/.local/lib/python3.8/site-packages} ou \textbf{~/.local/lib/python3.8/dist-packages} sur Linux. Lorsque \textit{Anaconda} est installé et que son environnement est activé par défaut au démarrage de la machine, cet emplacement devient \textbf{~/anaconda3/bin}. On peut chercher son emplacement exact et déplacer ensuite le package mais ceci n'a aucun d'intérêt vu que le système connaît l'emplacement de ses packages.

On peut se poser la question de savoir comment accéder aux différents fichiers support une fois que le code du package est exécuté, sachant que l'exécution se fait depuis un répertoire courant alors que le module \textbf{\_\_main\_\_.py} se trouve à l'emplacement prévu pour les packages. Quelle est donc la référence choisie pour définir le bon chemin d'accès ? L'utilisation d'un chemin d'accès absolu ne semble pas être une solution viable car ce chemin est dépendant de chaque système d'exploitation utilisé. \_file\_ TODO

En fait, l'exécution d'un package se fait à partir d'un répertoire courant et tous les fichiers nécessaires à son fonctionnement sont atteints par rapport à une référence relative XXX. L'emplacement du package dans le système est donc transparente pour l'utilisateur. Lorsque celui-ci exécute \texttt{python -m crisprbuilder\_tb \textemdash \textemdash collect ERR2704808}, le système cherche le package dans \textbf{site-packages}, puis le fichier \textbf{\_\_init\_\_.py} et à partir de là exécute le module \textbf{\_\_main\_\_.py}. Les fichiers nécessaires au fonctionnement sont atteignables grâce à l'adresse relative qui ne contient pas le nom du répertoire \textbf{crisprbuilder\_tb} car lors de la lecture du fichier \textbf{\_\_main\_\_.py} l'exécution du code se trouve déjà dans le package. Il ne se trouve en fait aucun fichier ou répertoire à l'intérieur du répertoire courant où l'archive n'a pas été téléchargée contrairement à ce qu'on pourrait imaginer.




Le package CRISPRbuilder\_TB ne fonctionne pas comme un module qu'on importerait en début de code Python afin d'en utiliser les différentes méthodes.

Par ailleurs, il n'est pas prévu que l'utilisateur se place dans le package pour exécuter directement le module \textbf{\_\_main\_\_.py} en écrivant en ligne de commande
\texttt{ python crisprbuilder\_tb \textemdash \textemdash collect ERR2704808}
sans le "-m", car dans ce cas l'exécution entraînerait la levée d'une exception due aux différents chemins d'accès qui seraient erronés. (explications des chemins d'accès ci-dessous)

L'exécution du package est réalisée en ligne de commande, et une fois que l'utilisateur a écrit 
\begin{verbatim}  python -m crisprbuilder_tb --collect ERR2704808\end{verbatim}

l'interpréteur va chercher le package à son emplacement de stockage XXX et l'exécute comme si ce dernier se trouvait dans le répertoire courant. Pourtant, le package ne se trouve pas dans le répertoire courant et tous les chemins d'accès aux bases de données et modules du package doivent tenir compte de la variable d'environnement placée au début de chaque chemin d'accès.



% CHOIX DES OUTILS -----------------------------
\chapter{Le choix des outils}




% L'ENVIRONNEMENT DE DEVELOPPEMENT -----------------------------
\section{L'environnement de développement}

TODO EXPLICATIONS REAL PYTHON

Avant de créer le package, il faut commencer par construire un programme qui fonctionne localement sur une machine bien paramétrée. Pour cela, nous définissons un \index{environnement de développement}environnement de développement, qui nous sert à exécuter le code et à l'évaluer au fur et à mesure de son élaboration. Cet environnement contient tous les modules et packages nécessaires à son bon fonctionnement, c'est à dire les dépendances du projet.
 
L'outil de création d'environnement virtuel \index{venv}\textit{venv} nous permet de créer cet environnement de développement afin de tester les codes du projet. \textit{venv} commence par constituer un dossier contenant tous les exécutables nécessaires à l'utilisation des modules d'un projet Python. 

Dans le cadre de notre étude, nous créons un répertoire \textbf{biologie}, nous nous plaçons dedans puis nous créons, à l'aide de \textit{venv}, un environnement de développement \textbf{env\_bio}. 
\begin{verbatim}  cd biologie
  python3 -m venv env_bio\end{verbatim}

Dans cet environnement vient d'être créé le répertoire \textbf{bin} comprenant notamment le fichier activate, qui permet d'activer les fonctionnalités de notre environnement.
Cette activation ne peut se faire qu'à partir du répertoire parent \textbf{biologie}. Il faut ensuite se placer à l'intérieur de \textbf{env\_bio} pour définir les modules utiles à l'environnement. 
 \begin{verbatim}  source env_bio/bin/activate
  (env_bio)  cd env_bio\end{verbatim}

De nombreux systèmes d'exploitation incorporent Python2.7 par défaut. Il convient donc de définir une version 3 de Python dans cet environnement de développement, et plus précisément une version 3.7 ou supérieure. Pour cela, le module \textit{pyenv} \index{pyenv} nous permet de définir une version de Python comme version locale de travail dans l'environnement. 

On peut ainsi choisir parmi les versions disponibles, grâce à l'instruction
\begin{verbatim}  pyenv install --list\end{verbatim}
La liste étant particulièrement longue, on peut éventuellement être plus spécifique en demandant les versions allant de 3.6 à 3.8 avec l'instruction
\begin{verbatim}  pyenv install --list | grep " 3\.[678]"\end{verbatim}

L'installation de la version 3.8.0 par exemple se fait grâce à l'instruction
\begin{verbatim}  pyenv install -v 3.8.0\end{verbatim}

La version 3.8.0 de Python se trouve maintenant installée dans \textbf{\raisebox{-1ex}{\textasciitilde}/.pyenv/versions/}

Pour connaître toutes les versions de Python installées par pyenv, il suffit d'exécuter l'instruction suivante qui fournit une liste de résultats
\begin{verbatim}    pyenv versions
  * system
    2.7.10
    3.6.2
    3.8.0\end{verbatim}
où le caractère "*" indique la version active dans le répertoire courant.

On peut alors choisir la version 3.8.0 pour notre environnement de travail. Il suffit de se placer dans cet environnement et d'exécuter l'instruction
\begin{verbatim}  pyenv local 3.8.0\end{verbatim}

On peut vérifier que l'environnement a bien configuré la version 3.8.0 en exécutant

\begin{verbatim}    pyenv versions
    system
    2.7.10
    3.6.2
  * 3.8.0\end{verbatim}

ou dans un cadre plus général, l'instruction
\texttt{  python \textemdash-version} qui
permet de connaître quelle version de Python est utilisée dans le répertoire courant, qu'on se trouve dans un environnement de développement ou non.

En fait, \textit{pyenv} s'insère dans la variable d'environnement PATH et devient l'exécutable appelé par le système d'exploitation. On peut voir que l'interpréteur Python utilise bien cet environnement \textit{pyenv} pour appeler Python grâce à l'instruction
\texttt{   which python}
qui renvoie \textbf{\raisebox{-1ex}{\textasciitilde}/.pyenv/shims/python} au lieu de \textbf{/usr/bin/python}.

Finalement, nous installons dans notre environnement de développement les dépendances nécessaires à l'aide de l'outil \textit{pip}\index{pip} :
\begin{itemize}
\item \begin{verbatim}  pip install xmltodict\end{verbatim}
le module \textit{xmltodict} permet de lire du code XML comme si il s'agissait de code JSON. Il permet donc une lecture plus rapide des fichiers.
\item  \begin{verbatim}  pip install openpyxl\end{verbatim}
le package \textit{openpyxl} permet de lire et d'écrire dans des fichiers Excel au format \textit{xlsx, xlsm, xltx} ou \textit{xltm}. Il comprend les modules \textit{et-xmlfile} et \textit{jdcal}. Il sera utile pour lire et transformer des fichier Excel mais ne sera pas nécessaire pour le fonctionnement du package.
\item  \begin{verbatim}  pip install xlrd\end{verbatim}
le module \textit{xlrd} extrait des données d'un tableur Excel à partir de la version 2.0 et avant de les formatter.
\item  \begin{verbatim}  pip install biopython\end{verbatim}
le package \textit{biopython} regroupe un ensemble d'outils Python pour le traitement informatique de la biologie moléculaire et comprend le module numpy.
\item \begin{verbatim}  pip install parallel-fastq-dump\end{verbatim}
le package \textit{parallel-fastq-dump} permet de téléchargement de fichiers fasta en utilisant plusieurs threads simultanément. Il procure donc un gain de temps à l'application.
\item \begin{verbatim}  pip install blast\end{verbatim}
\end{itemize}

Notons que certains modules utilisés dans ce package sont nativement présents dans la librairie standard Python3. C'est le cas par exemple :
\begin{itemize}
\item du module \textit{os} qui fournit une manière portable d'utiliser les fonctionnalités dépendantes du système d'exploitation,
\item du module \textit{pickle} qui permet de sérialiser et désérialiser une structure d'objet Python. Il remplace le module primitif \textit{marshal},
\item du module \textit{csv} qui implémente des classes pour lire et écrire des données liées à des feuilles de calcul ou des bases de données au format \textit{.csv},
\item du module \textit{shutil} qui propose des opérations sur les fichiers et collections de fichiers, notamment la copie et suppression de fichiers,
\item du module \textit{subprocess.run} qui permet de gérer de nouveaux processus, de se connecter à leurs flux d'input/output/erreurs. Il remplace plusieurs modules dépréciés : \textit{os.system, os.spawn*, os.popen*, popen2.*, commands.* },
\item du module \textit{pathlib} qui fournit des classes de chemins purs indépendants du système d'exploitation, ce qui permet au code de manipuler des chemins sans accéder au système d'exploitation,
\item du module \textit{argparse} qui gère la création et l'utilisation d'interfaces en ligne de commande.
\end{itemize}

Le package, une fois installé par l'utilisateur, devra fournir un environnement de travail similaire à celui que nous venons de construire, c'est à dire que les dépendances nécessaires à son bon fonctionnement devront également être installées. Ce processus devrait rester transparent pour l'utilisateur et être pris en charge par un gestionnaire de package tel que \textit{Poetry} qui regroupe ces modules dans un fichier appelé \textbf{pyproject.toml}. Nous verrons au cours des tests de fonctionnement que les dépendances ne sont pas toujours reconnues à partir de \textit{Poetry} et qu'il est nécessaire que l'utilisateur ait préalablement installé et paramétré les outils du SRA Toolkit \textit{parallel-fastq-dump} et \textit{blast}. 

On pourrait par exemple retrouver les modules installés via \textit{pip} dans un fichier \textit{requirements.txt} construit en gelant l'état de l'environnement à un moment précis grâce à une instruction du type
\begin{verbatim}  pip freeze > requirements.txt\end{verbatim}.

On pourrait alors ré-installer ces modules à l'identique en utilisant l'instruction
\begin{verbatim}  pip install -r requirements.txt\end{verbatim}

Cette méthode fonctionne bien pour construire un environnement de développement à partir d'un répertoire courant où se trouve le fichier requirements.txt. Toutefois, lors de la création d'un package, le fichier requirements.txt serait compressé dans l'archive puis intallé à l'emplacement désigné des packages pour chaque ordinateur (\textbf{site-packages} par exemple). Il faudrait donc que l'utilisateur trouve d'abord cet emplacement pour ensuite exécuter le fichier requirements.txt. Nous pensons qu'il est plus simple pour l'utilisateur de suivre la documentation crisprbuilder\_tb.md et de procéder lui-même à l'installation des dépendances en ligne de commande.



% PARAMETRAGE DE L'ENVIRONNEMENT ------------------
\section{Le choix d'Anaconda, une alternative à l'environnement de développement}

Nous venons de voir qu'il est possible de créer un environnement de développement adapté à notre projet, sans modifier le reste de la structure de notre machine. Toutefois, cet environnement nécessite un paramétrage de la variable d'environnement \$PATH afin que les modules recherchés puissent être trouvés par le système au moment de l'exécution du package.

PARAMETRAGE PATH

Il existe un autre moyen qui a retenu notre attention uniquement à la fin du projet, car il s'avère plus simple. Il consiste tout d'abord à mettre à jour Python dans une version récente (supérieure ou égale à 3.7), puis à installer le package \textit{Anaconda}, qui comprend notamment l'outil \texttt{  conda} et le module \textit{bioconda} dont nous aurons besoin. Il faut ensuite installer toutes les dépendances du projet à l'aide de \texttt{  conda}. Ces dépendances s'installent systématiquement dans XXX et la variable d'environnement \$PATH se met automatiquement à jour.

Attention toutefois de ne pas installer conjointement \textit{Anaconda} avec \textit{Miniconda}. En effet, dans ce cas certaines dépendances s'installent dans XXX et d'autres dans XXX. C'est tentant au début car \textit{Miniconda} donne accès à l'outil \texttt{  conda} et au module \textit{bioconda}, mais ce dernier nécessite \textit{Anaconda} pour installer certaines dépendances. Pour éviter tout problème de chemin d'accès, il faut donc désinstaller \textit{Miniconda} avant d'installer \textit{Anaconda}. 

L'installation de \textit{Anaconda} est décrite sur le site \url{https://docs.anaconda.com/anaconda/install/linux/}. Il faut penser à ordonner les priorités des différents \textit{channels}, dont notamment \textit{bioconda} en ajoutant dans l'ordre

\begin{verbatim}
  conda config --add channels defaults
  conda config --add channels bioconda
  conda config --add channels conda-forge
\end{verbatim}

 Il convient ensuite d'installer toutes les dépendances 
\begin{verbatim}  conda install -c conda-forge xmltodict
  conda install -c anaconda openpyxl
  conda install -c anaconda xlrd
  conda install -c anaconda biopython
  conda install -c bioconda parallel-fastq-dump
  conda install -c bioconda blast
  conda install -c kantorlab blastn\end{verbatim}

Notons que, contrairement au choix de créer un environnement de développement, \textit{Anaconda} propose un environnement de travail à tendance scientifique pour l'ensemble de la machine.




% L'OUTIL D'EMPAQUETAGE --------------------
\section{L'outil d'empaquetage}
	
	Le PyPA recommande l'utilisation de :
\begin{itemize}
\item \textit{setuptools} pour définir des projets et créer des sources de distribution,
\item \textit{pip} pour l'installation de librairies à partir de PyPI \textit{Python Package Index},
\item \textit{pipenv} pour la gestion des dépendances de packages lors du développement d'applications,
\item \textit{venv} pour isoler les dépendances particulières d'une application et créer un environnement de travail,
\item \textit{pyenv} pour la gestion des versions de Python,
\item \textit{conda} permettant de fournir un environnement de travail favorable aux projets scientifiques, avec notamment tous les modules essentiels pré-installés,
\item \textit{buildout} pour les projets de développement Web,
\item \textit{poetry} pour un besoin particulier non couvert par \textit{pipenv}.

\end{itemize}

Au regard de ces recommandations, nous avons testé les outils suivants dans le but de définir un environnement de développement et de construire un package incorporant les dépendances requises.

\textit{pipenv} est un gestionnaire de haut niveau pour les environnements, les dépendances et les packages Python. Contrairement à \textit{virtualenv}, \textit{pipenv} distingue les dépendances du projet et les dépendances des dépendances du projet. Par ailleurs, \textit{pipenv} différencie le mode développement du mode production. Il offre l'avantage de bien fonctionner sur Windows. Toutefois, la communauté Python l'a peu mis à jour depuis 2018.

\textit{Anaconda} est une distribution de logiciels multiplateformes (Windows, Linux, macOS) qui facilite l'installation des librairies scientifiques \textit{Numpy} et \textit{Scipy}, ce qui est particulièrement intéressant dans le cas des plateformes Windows où ce processus est plus complexe. Elle incorpore une librairie open-source appelée \textit{conda} permettant la gestion des dépendances, de l'environnement de travail ainsi que la création de packages. \textit{Anaconda} semble être approprié au projet, mais c'est une distribution trop lourde pour être intégrée à notre package et \textit{Miniconda}, qui ne comporte que Python, \textit{conda} et \textit{pip}, ne répond pas aux besoins du projet. Nous n'abandonnerons pas pour autant la distribution \textit{Anaconda}, car son utilité va se révéler au cours des tests d'installation. 

Nous avons tout d'abord cherché à construire le package manuellement, à partir de \textit{pipenv} associé à \textit{pip}, puis de \textit{conda} qui dispose d'une riche bibliothèque. Cet effort s'est avéré laborieux et a révélé des incompatibilités lors du \textit{build} qui n'ont pas permis de valider les exigences de la plateforme \textit{testPyPI}.

Nous avons donc décidé de construire notre package en utilisant \textit{Poetry}, qui est un outil complet multiplateformes autour duquel la communauté Python reste très active. Il propose à la fois la gestion des dépendances, l'empaquetage (création d'une structure pour un projet et la génération de fichiers de configuration et de manifestes) et la publication. \textit{Poetry} automatise ces différents procédés et facilite grandement le travail. Nous étudions en détail l'utilisation de cet outil dans la section suivante.
	


% POETRY ---------------
\chapter{Construction du package avec Poetry}



% CREATION DU PACKAGE ---------------
\section{Création du package et gestion des dépendances}

Pour créer notre projet, il ne faut pas commencer par définir un dossier du nom du package, car cela sera automatiquement fait par \index{Poetry}\textit{Poetry}. Il suffit d'exécuter l'instruction

\begin{verbatim}
  poetry new crisprbuilder_tb
\end{verbatim}

qui permet de générer le squelette de l'application contenant les éléments suivants.

\includegraphics[width=6cm]{nom_package_tree.png}

\begin{itemize}
\item le répertoire \textbf{crisprbuilder\_tb} contient initialement le fichier \textbf{\_\_init\_\_.py} et c'est dans ce répertoire que nous allons rajouter tous les composants principaux du code  \textbf{\_\_main\_\_.py}, \textbf{fonctions.py}, \textbf{bdd.py} et les répertoires \textbf{data}, \textbf{doc}, \textbf{REP} et \textbf{tmp} avec leurs contenus. En effet, la création de l'archive va compresser ce répertoire \textbf{crisprbuilder\_tb} afin de le publier. Il devra contenir tout ce qui est nécessaire au fonctionnement de l'application. Lors de sa création, le fichier\textbf{\_\_init\_\_.py} contenait uniquement la version du package. Pour éviter tout conflit de version avec le fichier \textbf{pyproject.toml}, nous vidons le fichier \textbf{\_\_init\_\_.py} du répertoire \textbf{crisprbuilder\_tb}
\item le répertoire \textbf{tests} contient les tests unitaires relatifs au bon fonctionnement du package
\item le fichier \textbf{README.rst} fournit une brève description du package, et nous le modifions au format markdown \textbf{README.md} à l'usage plus répandu
\item le fichier \textbf{pyproject.toml} remplace les anciens standards de définition de packages : \textbf{setup.exe} et \textbf{requirements.txt}. Il précise notamment le nom du package, sa version, sa description, l’emplacement de son dépôt (par exemple sur GitHub), l’adresse email de l’auteur du package, et la version des dépendances
\item nous rajoutons à la racine du package un fichier \textbf{LICENSE}, un fichier \textbf{.gitignore} pour la gestion des versions. 
\end{itemize}

Notons qu'il est préférable de choisir un nom de package en minuscules pour éviter toute confusion car, bien que les majuscules soient conservées sur PyPI, l'appel du package en ligne de commande devra s'effectuer en minuscules. En outre, par convention il faut éviter le symbole '-' qui est automatiquement remplacé par '\_' lors de la création du package.

En ce qui concerne la gestion des versions de dépendances, il faut tout d'abord se placer dans le répertoire \textbf{crisprbuilder\_tb} puis utiliser l’instruction
\texttt{  poetry add nom\_dependance}  
qui assure la compatibilité de la dépendance \textit{nom\_dependance} avec le package \textit{crisprbuilder\_tb}. Il est également possible d’imposer certaines contraintes sur les versions des dépendances ou encore de rentrer manuellement les dépendances dans le fichier pyproject.toml, mais l’instruction 
\texttt{\$ poetry add nom\_dependance} 
offre l’avantage de chercher automatiquement une version compatible de la dépendance, puis de l’inscrire dans pyproject.toml.

%\begin{tcolorbox} \end{tcolorbox}
Il faut donc ajouter les dépendances suivantes au projet :
\begin{verbatim}  cd crisprbuilder_tb 
  poetry add xlrd 
  poetry add xmltodict 
  poetry add biopython
  poetry add parallel-fastq-dump \end{verbatim}

Le fichier \textbf{pyproject.toml} comporte maintenant les versions suivantes

\begin{verbatim}  [tool.poetry.dependencies]
  python = "^3.7"
  xlrd = "^1.2.0"
  xmltodict = "^0.12.0"
  biopython = "^1.77"
  parallel-fastq-dump = "^0.6.5"\end{verbatim}

Notons que la version de Python se complète automatiquement d'après celle utilisée par défaut lors de l'appel au module \textit{Poetry}. On peut toutefois le changer manuellement dans le fichier \textbf{pyproject.toml}. On peut également compléter manuellement ce fichier pour fournir des informations d'ordre général du type

\begin{verbatim}  [tool.poetry]
  name = "crisprbuilder_tb"
  version = "0.1.2"
  description = "Collect and annotate Mycobacterium tuberculosis WGS data for CRISPR investigations."
  authors = ["stephane-robin <robin.stephane@outlook.com>"]
  license = "MIT"
  readme = "README.md"
  homepage = "https://github.com/stephane-robin/crisprbuilder_tb.git"
  repository = "https://github.com/stephane-robin/crisprbuilder_tb.git"
  keywords = ["tuberculosis", "CRISPR"]}\end{verbatim}

La rubrique [tool.poetry.dev-dependencies] définit le module qui procèdera aux tests unitaires concernant le fonctionnement du package.

La rubrique [build-system] définit les versions de \textit{Poetry} et \textit{poetry.masonry.api} nécessaires à la construction du package.

Pour installer ensuite les dépendances du projet au sein du package, il est nécessaire d’utiliser l’instruction
\texttt{ poetry install}
qui crée les fichiers \textbf{poetry.lock} et \textbf{setup.py}, ainsi que le répertoire \textbf{crisprbuilder\_tb.egg-info} comprenant le code, les ressources et les métadonnées du projet. Ce format facilite la désinstallation et la mise à niveau du code, car le projet est essentiellement autonome dans un unique répertoire. Il autorise ainsi l'installation de plusieurs versions d'un même projet simultanément. Il s'agit d'un format adapté à la distribution de plugins pour des applications extensibles et des frameworks, similaire au format \textit{.jar} en Java. Il permet également de distribuer les gros packages en entités séparées. De son côté, \textbf{poetry.lock} empêche les dépendances de télécharger la dernière version au moment de l’installation, en fixant la version utilisable par le package. Dans le cas de \textit{Poetry}, \textbf{setup.py} n'est en fait qu'un fichier temporaire servant à la construction de \textbf{crisprbuilder\_tb.egg-info}. 

Lors de l'exécution du code \texttt{ poetry install}, on constate que \textit{Poetry} crée en fait un environnement virtuel dans lequel il va installer les dépendances et le package

\begin{verbatim}  poetry install
  Creating virtualenv crisprbuilder-tb-oJzk4q3N-py3.8 in ~/.cache/pypoetry/virtualenvs
  Installing dependencies from lock file

  Package operations: 14 installs, 0 updates, 0 removals

    - Installing pyparsing (2.4.7)
    - Installing six (1.14.0)
    - Installing atomicwrites (1.4.0)
    - Installing attrs (19.3.0)
    - Installing more-itertools (5.0.0)
    - Installing numpy (1.18.4)
    - Installing packaging (20.3)
    - Installing pluggy (0.13.1)
    - Installing py (1.8.1)
    - Installing wcwidth (0.1.9)
    - Installing biopython (1.76)
    - Installing pytest (4.6.9)
    - Installing xlrd (1.2.0)
    - Installing xmltodict (0.12.0)
    - Installing parallel-fastq-dump (0.6.5)
    - Installing crisprbuilder_tb (0.1.26)\end{verbatim}

Notons qu'on peut s'assurer à ce moment-là de la version de Python utilisée pour tout le travail de construction, à savoir dans cet exemple Python 3.8 qui apparaît à la fin de \texttt{crisprbuilder-tb-oJzk4q3N-py3.8}.




% CONSTRUCTION DU PACKAGE ET PUBLICATION -------------------
\section{Construction du package et publication}

Pour empaqueter le projet, il faut utiliser l’instruction
\texttt{ poetry build}
qui va permettre de créer un répertoire source \textbf{dist} contenant une archive \textbf{crisprbuilder\_tb-0.1.2.tar.gz} et une distribution compilée \textbf{crisprbuilder\_tb-0.1.2-py3-none-any.whl}. Lors de l'exécution du code \texttt{ poetry build}, on constate bien la constitution des fichiers mentionnés

\begin{verbatim}  poetry build
  Building crisprbuilder_tb (0.1.2)
    - Building sdist
    - Built crisprbuilder_tb-0.1.2.tar.gz

    - Building wheel
    - Built crisprbuilder_tb-0.1.2-py3-any.whl\end{verbatim}

Attention, si la distribution comporte la mention "py2" au lieu de "py3", cela signifie que la construction sous \textit{Poetry} a été réalisée à partir de Python 2. Il faut donc bien s'assurer de choisir une version de Python 3 avant la création du package.

On peut vérifier la conformité du package avec l’instruction
\texttt{ poetry check}
qui renvoie
\texttt{ All set !}
si le package ne comporte aucune discordance et peut être publié.

Avant d'être publié, la structure du package est la suivante

\includegraphics[width=6cm]{tree_level1.png}

Notons que le fichier \textbf{README.md} reste en dehors du répertoire \textbf{crisprbuilder\_tb}, car à cet emplacement il peut être lu par PyPI, et constitue le contenu de la rubrique "Package description" sur les sites \href{https://www.pypi.org}{https://www.pypi.org} ou encore \href{https://www.test.pypi.org/project/crisprbuilder\_tb}{https://www.test.pypi.org/project/crisprbuilder\_tb}

Le dossier \textbf{crisprbuilder\_tb} contient maintenant les éléments suivants

\includegraphics[width=8cm]{rep_crispr.png}

Le dossier \textbf{crisprbuilder\_tb.egg-info} contient désormais les éléments suivants

\includegraphics[width=5cm]{rep_crispr_egg.png}

Le dossier \textbf{dist} contient les éléments suivants

\includegraphics[width=9cm]{rep_dist.png}

Lorsque le package est finalement prêt pour être publié sur PyPI, on utilise l’instruction
\begin{verbatim}  poetry publish\end{verbatim}
Pour cela, l'auteur du package doit être enregistré sur PyPI avec un identifiant et un mot de passe. A partir de ce moment-là, le package est rendu disponible publiquement.

Notons qu'on peut publier une nouvelle version du package et on peut bien entendu supprimer le package sur PyPI. En revanche, par mesure de sécurité, il n'est pas possible de re-créer un package du même nom que celui déjà supprimé et encore moins de modifier une version déjà publiée. 

On pourra retrouver un cas concret simple de publication de package avec \textit{Poetry} dans le tutoriel que nous venons de publier sur YouTube : \href{http://www.youtube.com}{http://www.youtube.com}





% LA STRUCTURE DU PACKAGE TEL QU'IL EST INSTALLE CONSTRUIT PAR POETRY -------------------------
\section{La structure du package construit par Poetry}

Le fichier \textbf{crisprbuilder\_tb-0.1.2.tar.gz} est une archive qui, une fois décompressée contient les éléments suivants :

\includegraphics[width=7cm]{tar.png}

On constate la même arborescence que celle obtenue lors de la création du package, avec en supplément les fichiers \textbf{PKG.INFO} et \textbf{setup.py}

\begin{itemize}
\item un répertoire \textbf{doc} comprenant la documentation nécessaire pour comprendre et utiliser convenablement le package,
\item un répertoire \textbf{\_\_pycache\_\_} comprenant des fichiers compilés et un fichier \_\_init\_\_.py,
\item un répertoire \textbf{data} comprenant les bases de données utiles au programme, sans aucun module et donc aucun fichier \textbf{\_\_init\_\_.py},
\item un répertoire \textbf{REP} comprenant un répertoire séquences qui contient les résultats de recherche au sujet de différents SRA,
\item un répertoire \textbf{tmp} comprenant un fichier nb.txt qui change pour chaque SRA
\item à la racine du package, les fichiers \textbf{\_\_init\_\_.py}, \textbf{\_\_main\_\_.py}, \textbf{fonctions.py} et \textbf{bdd.py}.
\end{itemize}

Notons que tous les répertoires comprenant des modules Python doivent contenir un fichier
\textbf{ \_\_init\_\_.py}.



% LE PACKAGE CRISPRBUILDER --------------------------------
\chapter{La documentation du package \\(version originale)}


La création d'un package nécessite l'élaboration d'une documentation détaillée en anglais permettant de bien comprendre son fonctionnement. Une documentation trop succincte ou peu détaillée aurait pour conséquence le manque d'intérêt pour le package ou une incompréhension légitime qui démotiverait ses utilisateurs.

Cette documentation doit comporter trois volets :
\begin{itemize}
\item une \textit{docstring} inclue dans le code au début de chaque fonction et de chaque module,
\item un fichier \textbf{README.md} servant à la fois de description succincte du package pour le site de PyPI et de manuel d'instruction pour les utilisateurs les plus pressés,
\item une documentation détaillée \textbf{crisprbuilder\_tb.ipynb} qu'on peut retrouver sur \\ \url{https://github.com/stephane-robin/crisprbuilder_tb/blob/master/crisprbuilder_tb/doc/crisprbuilder_tb.ipynb}, et qui est également inclue dans le package sous le répertoire \textbf{doc}.
\end{itemize}   

Nous présentons ci-dessous cette documentation détaillée dans sa version originale en anglais.

\includegraphics[width=5cm]{femto.png}

The CRISPRbuilder\_TB package is an open source software made available
under generous terms. Please see the LICENSE file for further details.

If you use CRISPRbuilder\_TB in work contributing to a scientific
publication, we ask that you cite the following application note:
Femto-ST Institute, UMR 6174 CNRS, University of Bourgogne
Franche-Comté, France.

This package originated in the work of Section \cite{guyeux1} and
Section \cite{guyeux2}.



% PURPOSE OF THIS PACKAGE ----------------
    \section{Purpose of this package}\label{purpose-of-this-package}

    CRISPRbuilder\_TB will help you collect and annotate Mycobacterium
tuberculosis whole genome sequencing data for CRISPR investigations.
Given a Sequence Read Archive reference, the package will provide the
genome information dictionary comprising the following elements:

\begin{itemize}
\item
  the reads - number of reads for the study, length of those reads,
  coverage of the study,
\item
  the study - source of publication for the SRA reference, authors who
  discovered it, location of discovery, date of discovery, center that
  discovered the SRA, reference of the study, study accession number,
\item
  identity - name of the SRA reference, strain for the SRA, taxid,
  bioproject number,
\item
  spoligotypes - description, numbers, new version numbers, vitro
  description, vitro numbers, vitro new version description, vitro new
  version numbers, Spoligotype International Type, Spoligotype
  International Type silico,
\item
  lineages - Coll et al. 2014 (for all lineages) Section \cite{coll-preston},
  Stucki et al. 2016 (for Lineage 4) Section \cite{stucki-brites},
  Palittapongarnpim et al. 2018 (for Lineage 1) Section \cite{pali-ajaw},
  Shitikov et al. 2017 (for Lineage 2) Section \cite{shiti-kolchenko}.
\end{itemize}


% HOW TO INSTALL THE PACKAGE ------------------------
    \section{How to install the package
?}\label{how-to-install-the-package}

Make sure your system is set to \textbf{Python 3} in your current directory and \textit{pip} is set to work with Python 3, before using the \texttt{ pip} instruction and executing the package. The defaulit version on your computer might be different. You can also check that \textit{pip} is linked to Python3 by writing \texttt{ pip \textemdash \textemdash version}, which will display a line similar to

\begin{verbatim}
pip 20.1.1 from ~/pyenv/versions/3.8.0/lib/python3.8/site-packages/pip (python 3.8)
\end{verbatim}

    This package comes with a Command Line Interface, so it should be
installed and executed using your command prompt. For Linux, MacOS or
Windows platforms, the installation requires the same instruction. From your current directory, execute the following line:

    \begin{verbatim}
  pip install crisprbuilder_tb
\end{verbatim}

    Please note that \texttt{cripsrbuilder\_tb} is written without capital
letters in the command prompt.

First the program will download the last version of CRISPRbuilder\_TB, and the dependencies \textit{xmltodict, parallel-fastq-dump, xlrd, biopython, numpy}. Then it will install the dependencies and the package.

\begin{verbatim}  Collecting crisprbuilder_tb
  Collecting xmltodict<0.13.0,>=0.12.0 (from crisprbuilder_tb)
  Collecting xlrd<2.0.0,>=1.2.0 (from crisprbuilder_tb)
  Collecting parallel-fastq-dump<0.7.0,>=0.6.5 (from crisprbuilder_tb)
  Collecting biopython <2.0,>=1.77 (from crisprbuilder_tb)
  Collecting numpy (from biopython<2.0,>=1.77->crisprbuilder_tb)
  Installing collected packages: xmltodict, xlrd, parallel-fastq-dump, numpy, biopython, crisprbuilder_tb
  Successfully installed biopython-1.77 crisprbuilder_tb-1.2.0 numpy-1.19.0 parallel-fastq-dump-0.6.5 xlrd-1.2.0 xmltodict-0.12.0
\end{verbatim}

 It is not necessary to first install the dependencies, since CRISPRbuilder\_TB will deal with them on its own.

If a previous version of CRISPRbuilder\_TB already exists on your computer, you can upgrade it using 

\begin{verbatim}
  pip install --upgrade crisprbuilder_tb
\end{verbatim}

If this instruction doesn't work, you can enforce the upgrade by first removing the package before installing it again

\begin{verbatim}
  pip uninstall crisprbuilder_tb
  pip install crisprbuilder_tb
\end{verbatim}

You can also choose a specific version of the package on PyPI, like for example

\begin{verbatim}
  pip install crisprbuilder_tb==1.2.0
\end{verbatim}



% HOW TO USE THE COMMAND LINE INTERFACE --------------------
    \section{How to use the Command Line Interface
?}\label{how-to-use-the-command-line-interface}

    After installing the package, you can find help with the command prompt,
listing the different available options, such as \texttt{-\/-collect},
\texttt{-\/-list}, \texttt{-\/-add}, \texttt{-\/-print},
\texttt{-\/-remove}, \texttt{-\/-change}, and their expected syntax.
Stay in the directory containing the installed package and write in the
command prompt:

    \begin{verbatim}
  python -m crisprbuilder_tb --help
\end{verbatim}

    The help menu will display the following information:

    \begin{verbatim}
  usage: crisprbuilder_tb [-h] [--collect] [--list] [--add] [--remove] [--change]
  [--print] sra

  Collects and annotates Mycobacterium tuberculosis whole genome sequencing data
  for CRISPR investigation.

  positional arguments:
    sra         requires the reference of a SRA, the path to a file of SRA references
                or 0. See doc.

  optional arguments:
    -h, --help  show this help message and exit
    --collect   collects the reference of a SRA to get information about this SRA. 
                See doc.
    --list      collects the path to a file of SRA references to get information 
                about. See doc.
    --add       collects data to add to the file data/lineage.csv. Requires 0 as 
                argument. See doc.
    --remove    removes data from the file data/lineage.csv. Requires 0 as 
                argument. See doc.
    --change    collects data to update the file data/lineage.csv. Requires 0 as
                argument. See doc.
    --print     prints the file data/lineage.csv. Requires 0 as argument. See doc.
\end{verbatim}



% EXECUTING CRISPRBUILDER_TB WITH A SRA REFERENCE ------------
    \subsection{Executing CRISPRbuilder\_TB with a SRA
reference}\label{executing-crisprbuilder_tb-with-a-sra-reference}

    You can run the package if you wish to find information regarding a
specific SRA. From your current directory, write in the command prompt:

    \begin{verbatim}
  python -m crisprbuilder_tb --collect {SRA_reference}
\end{verbatim}

    Please note the importance of "-m" to run crisprbuilder\_tb as a
package, otherwise the interpreter will look at crisprbuilder\_tb as a folder inside the current folder and not a package. CRISPRbuilder\_TB uses version 3 of Python, so make sure your system is set to Python 3 in your current directory before using the
\texttt{python}instruction. The default version on your computer might
be different.

\textbf{Caution:} it is not recommanded to find the location of the
package and go to the directory containing CRISPRbuilder\_TB in order to
execute it. If you are doing so, the instruction above won't work.

    \textbf{Exemple:} to find information about SRR8368696, write:

    \begin{verbatim}
  python -m crisprbuilder_tb --collect SRR8368696
\end{verbatim}


% EXECUTING CRISPRBUILDER_TB WITH A LIST OF SRA REFERENCES -----
    \subsection{Executing CRISPRbuilder\_TB with a list of SRA
references}\label{executing-crisprbuilder_tb-with-a-list-of-sra-references}

    To run the package with a list of SRA references, this list must be
composed of one SRA reference per line in a txt format file. Then, if
you wish to find information regarding a list of specific SRAs, stay in
the directory containing the package and write in the command prompt:

    \begin{verbatim}
  python -m crisprbuilder_tb --list {path_to_the_file}
\end{verbatim}

    \textbf{Exemple:} to find information about the different SRAs included
in the file \textbf{my\_file.txt} from the \textbf{Documents} directory,
write:

    \begin{verbatim}
  python -m crisprbuilder_tb --list /Documents/my_file.txt
\end{verbatim}



% PRINTING THE DATABASE LINEAGE.CSV --------------------------
    \subsection{Printing the database
lineage.csv}\label{printing-the-database-lineage.csv}

    If you want to consult the \textbf{lineage.csv} database, stay in the
directory containing the package and write in the command prompt:

    \begin{verbatim}
  python -m crisprbuilder_tb --print 0
\end{verbatim}

    \textbf{Caution:} it is necessary to add the 0 after \texttt{-\/-print}.

The program will then display the content of the database
\textbf{lineage.csv} whose extract can be read below:

\includegraphics[width=16cm]{img_01.png}



% ADDING A RECORD TO LINEAGE.CSV ------------------------
    \subsection{Adding a record to
lineage.csv}\label{adding-a-record-to-lineage.csv}

    If you want to add a record to the \textbf{lineage.csv} database, stay
in the directory containing the package and write in the command line:

    \begin{verbatim}
  python -m crisprbuilder_tb --add 0
\end{verbatim}

    \textbf{Caution:} it is necessary to add the 0 after \texttt{-\/-add}.

You will then be asked the values of the different fields (lineage,
position, gene coordinates, allege change, codon number, codon change,
amino acide change, locus ID, gene name, gene type, type of mutation, 5'
gene, 3' gene, strand, sublineage surname, essential, origin of the
study). In case you don't know the value of a particular field, just
press enter.



% REMOVING A RECORD FROM LINEAGE.CSV -------------------------------
    \subsection{Removing a record from
lineage.csv}\label{removing-a-record-from-lineage.csv}

    If you want to remove a record from the \textbf{lineage.csv} database,
stay in the directory containing the package and write in the command
line:

    \begin{verbatim}
  python -m crisprbuilder_tb --remove 0
\end{verbatim}

    \textbf{Caution:} it is necessary to add the 0 after
\texttt{-\/-remove}.

After your confirmation for removal, you will be asked for the reference
of the line you wish to delete, which consists of the lineage and the
position (see below). If you don't know this reference, you can always
print the \textbf{lineage.csv} database beforehand to find it.

\includegraphics[width=16cm]{selection.png}

    The execution of the code will end with:

    \begin{verbatim}
  The line has been removed.
\end{verbatim}

    or

    \begin{verbatim}
  Your request was cancelled.
\end{verbatim}

    in case the SRA reference is not correct.


% CHANGING A RECORD ------------------------
    \subsection{Changing a record from
lineage.csv}\label{changing-a-record-from-lineage.csv}

    If you want to change a record from the \textbf{lineage.csv} database,
stay in the directory containing the package and write in the command
line:

    \begin{verbatim}
  python -m crisprbuilder_tb --change 0
\end{verbatim}

    \textbf{Caution:} it is necessary to add the 0 after
\texttt{-\/-change}.

After confirmation for change, you will be asked for the reference of
the line you wish to delete, which consists of the lineage and the
position (see below). If you don't know the reference, you can always
print the \textbf{lineage.csv} database beforehand to find it.

\includegraphics[width=16cm]{selection.png}

    You will then be asked the values of the different fields: lineage,
position, gene coordinates, allege change, codon number, codon change,
amino acide change, locus ID, gene name, gene type, type of mutation, 5'
gene, 3' gene, strand, sublineage surname, essential, origin of the
study. In case you don't know the value of a particular field, just
press enter.

    The execution of the code will end with:

    \begin{verbatim}
  The line has been changed.
\end{verbatim}

    or

    \begin{verbatim}
  Your request was cancelled.
\end{verbatim}


% COMPOSITION OF THE PACKAGE AND DEPENDENCIES -------------
    \section{Composition of the package and
dependencies}\label{composition-of-the-package-and-dependencies}

    CRISPRbuilder\_TB needs the following dependencies to work:

\begin{itemize}
\item
  python = "\^{}3.6.4"
\item
  xlrd = "\^{}1.2.0"
\item
  openpyxl = "\^{}3.0.3"
\item
  xmltodict = "\^{}0.12.0"
\item
  biopython = "\^{}1.76"
\item
  datetime = "\^{}4.3"
\item
  parallel-fastq-dump
\item
  balstn+
\end{itemize}

These different versions are automatically downloaded when installing
CRISPRbuilder\_TB. Please note that this package doesn't support Python
2.

    The package structure is the following:

    \begin{itemize}
\item
  The \textbf{\_\_main\_\_.py} and \textbf{fonctions.py} files contain
  the actual code for the package,
\item
  the \textbf{bdd.py} file contains the Origines dictionary,
\item
  The \textbf{data} directory contains the necessary database to compare
  with the SRA reference when the code is executed,
\item
  The \textbf{REP/sequences} directory contains the different result
  database for each execution of the code. For example, you can find a
  directory ERR2704808 containing the fasta files ERR2704808\_1.fasta,
  ERR2704808\_2.fasta and ERR2704808\_shuffled.fasta along with the
  files ERR2704808.00.nhr, ERR2704808.00.nin, ERR2704808.00.nsq,
  ERR2704808.nal and the directory ERR2704808 containing the blast
  database. That's typically where you can find the files
  ERR2704808\_old.blast and ERR2704808\_new.blast.
\item
  The \textbf{doc} directory contains the necessary documentation to
  explain how this package works. It includes a \textbf{README.md} file
  explaining how to install the package for those who just need the
  essential, the copyright conditions for this package with the
  \textbf{LICENSE} file and the present documentation.
\end{itemize}

\includegraphics[width=8cm]{rep_crispr.png}



% RETRIEVING THE GENOME INFORMATION -------------------
    \section{Retrieving the genome information
dictionary}\label{retrieving-the-genome-information-dictionary}

    Let's assume you're looking for information regarding ERR2704808. After
writing \texttt{python3\ -m\ crisprbuilder\_tb\ -\/-collect\ ERR2704808}
in the command prompt, a directory called \textbf{ERR2704808} will be
created in \textbf{REP/sequences} and the item ERR2704808 will be added
to the database. The following message will be displayed:

    \begin{verbatim}
  We're creating a directory ERR2704808.
  We're adding ERR2704808 to the database.
\end{verbatim}

    Then the files in fasta format will be downloaded to
\textbf{REP/sequences/ERR2704808} as in the following code:

\begin{verbatim}
  if len([u for u in listdir(rep) if 'fasta' in u]) == 0:
      print("We're downloading the files in fasta format")

      try:
          completed = subprocess.run(['parallel-fastq-dump', '-t', '8',
                                      '--split-files', '--fasta', '-O', P_REP,
                                      '-s', item], check=True)
          completed.check_returncode()
          # if the download worked
          print("fasta files successfully downloaded.")
          for k in listdir(P_REP):
              if k.endswith('.fasta'):
                  p_item_k = str(PurePath(crisprbuilder_tb.__path__[0], 'REP',
                                          'sequences', item, k))
                  p_k = str(PurePath(crisprbuilder_tb.__path__[0], 'REP', k))
                  try:
                      move(p_k, p_item_k)
                  except FileNotFoundError:
                      print("We can't transfer the fasta files in the proper "
                            "repository.")
      except subprocess.CalledProcessError:
          # if the download didn't work, we delete the SRA from dico_afr
          del dico_afr[item]
          print("Failed to download fasta files.")
\end{verbatim}

    If ERR2704808\_shuffled.fasta is not in the \textbf{ERR2704808}
directory, then the ERR2704808\_1.fasta and ERR2704808\_2.fasta files
will be mixed in a new ERR2704808\_shuffled.fasta file in the
\textbf{ERR2704808} directory, as in the following code:

\begin{verbatim}
  p_shuffled = str(PurePath(crisprbuilder_tb.__path__[0], 'REP', 'sequences',
                            item, item + '_shuffled.fasta'))
      if item + '_shuffled.fasta' not in listdir(rep):

          print("We're mixing both fasta files, which correspond to the two "
                "splits ends.")

          p_fasta_1 = str(PurePath(crisprbuilder_tb.__path__[0], 'REP',
                                   'sequences', item, item + '_1.fasta'))
          p_fasta_2 = str(PurePath(crisprbuilder_tb.__path__[0], 'REP',
                                   'sequences', item, item + '_2.fasta'))

          if name == 'posix':
              system("sed -i 's/" + item + './' + item + "_1./g' " + p_fasta_1)
              system("sed -i 's/" + item + './' + item + "_2./g' " + p_fasta_2)
              system("cat " + p_fasta_1 + " " + p_fasta_2 + " > " + p_shuffled)
          else:
              fonctions.change_elt_file(p_fasta_1, '_1', item)
              fonctions.change_elt_file(p_fasta_2, '_2', item)
              fonctions.concat(p_fasta_1, p_fasta_2, p_shuffled)
\end{verbatim}

    The number of reads represented by '\textgreater{}' in
ERR2704808\_shuffled.fasta will be counted and assigned to nb\_reads, as
in the following code:

\begin{verbatim}
  if 'nb_reads' not in dico_afr[item] or dico_afr[item]['nb_reads'] == '':
      if name == 'posix':
          system("cat " + p_shuffled + " | grep '>' | wc -l > " + P_TXT_POSIX)
          nb_reads = eval(open(P_TXT_POSIX).read().split('\n')[0])
      else:
          with open(p_shuffled, 'r') as f_in, open(P_TXT_WIN, 'w') as f_out:
              lignes = f_in.readlines()
              cpt = 0
              for elt in lignes:
                  cpt += elt.count('>')
                  f_out.write(str(cpt))
          nb_reads = eval(open(P_TXT_WIN).read().split('\n')[0])

      dico_afr[item]['nb_reads'] = nb_reads
\end{verbatim}

    The length of the reads will be evaluated from
ERR2704808\_shuffled.fasta as in the following code:

\begin{verbatim}
  if 'len_reads' not in dico_afr[item]:
      nb_len = len(''.join(open(p_shuffled).read(10000).split('>')[1].split(
                   '\n')[1:]))
      dico_afr[item]['len_reads'] = nb_len
\end{verbatim}

    which eventually will be displayed by:

    \begin{verbatim}
  nb_reads: 14304698
  len_reads: 108
\end{verbatim}

    When starting the download, the following information will be displayed:

    \begin{verbatim}
  SRR ids: ['ERR2704808']
  extra args: ['--split-files', '--fasta']
  tempdir: /tmp/pfd_1a9adanv
  ERR2704808 spots: 7152349
  blocks: [[1, 894043], [894044, 1788086], [1788087, 2682129], [2682130, 3576172], [3576173, 4470215], [4470216, 5364258], [5364259, 6258301], [6258302, 7152349]]
\end{verbatim}

    If the NCBI server is busy or your connection unstable, the following
message could show up:

    \begin{verbatim}
  2020-05-09T09:25:58 fastq-dump.2.8.2 sys: libs/kns/unix/syssock.c:606:KSocketTimedRead: timeout exhausted while reading file within network system module - mbedtls_ssl_read returned -76 ( NET - Reading information from the socket failed )
\end{verbatim}

    Ignore the message and let the program run. It might take a while, but
you'll eventually find that the download is processing correctly with
the following message:

    \begin{verbatim}
  Read 894043 spots for ERR2704808
  Written 894043 spots for ERR2704808
  fasta files successfully downloaded.
  We're mixing both fasta files, which correspond to the two splits ends.
\end{verbatim}

    The coverage will be calculated and, if it is too, low the procedure
will be cancelled:

 \begin{verbatim}
  if 'couverture' not in dico_afr[item] or \
          dico_afr[item].get('couverture') == '':
      dico_afr[item]['couverture'] = round(dico_afr[item].get('nb_reads') *
                                           dico_afr[item].get('len_reads') /
                                           TAILLE_GEN, 2)
        
  if dico_afr[item].get('couverture') < 50:
      del dico_afr[item]
      print(f"The coverage is too low. {item} is being removed from the "
            "database")
\end{verbatim}

    which will be displayed by:

    \begin{verbatim}
  couverture: 350.2        
\end{verbatim}

    Then, a database for blast will be created in
\textbf{REP/sequences/ERR2704808/ERR2704808}, as in the code:

\begin{verbatim}
  if item+'.nal' not in listdir(rep) and item+'.nin' not in listdir(rep):
      print("We're creating a database for Blast")
      try:
          completed = subprocess.run(['makeblastdb', '-in', p_shuffled,
                                      '-dbtype', 'nucl', '-title', item,
                                      '-out', repitem], check=True)
          completed.check_returncode()
      except subprocess.CalledProcessError:
          print("We can't proceed blasting file.")
\end{verbatim}

    You will then read the following message:

    \begin{verbatim}
  We're creating a database for Blast
  Building a new DB, current time: 05/09/2020 12:18:30
  New DB name:   /home/stephane/Biologie/env_bio/CRISPRbuilder-TB/REP/sequences/  ERR2704808/ERR2704808
  New DB title:  ERR2704808
  Sequence type: Nucleotide
  Keep MBits: T
  Maximum file size: 1000000000B
  Adding sequences from FASTA; added 14304698 sequences in 1213.96 seconds.
\end{verbatim}

    Some research will eventually be made in the dataset Brynildsrud,
according to the code:

\begin{verbatim}
  brynildsrud = fonctions.to_brynildsrud()
  if item in brynildsrud:
      for elt in brynildsrud[item]:
          dico_afr[item][elt] = brynildsrud[item][elt]
          print(f"{item} is in the database Brynildsrud")
  else:
      print(f"{item} is not in the database Brynildsrud")
\end{verbatim}

    If ERR2704808 doesn't belong to the dataset Brynildsrud, the following
message will appear:

    \begin{verbatim}
  ERR2704808 is not in the database Brynildsrud
\end{verbatim}

    Sequences from the fasta files will be added and the spoligotypes will
be blasted, as in the code:

\begin{verbatim}
  if 'spoligo' not in dico_afr[item] or dico_afr[item]['spoligo'] == '':
      print("The spoligotypes are being blasted")
      dico_afr[item]['spoligo'] = ''
      dico_afr[item]['spoligo_new'] = ''

      p_spoligo_old = str(PurePath(crisprbuilder_tb.__path__[0], 'data',
                                   'spoligo_old.fasta'))
      p_spoligo_new = str(PurePath(crisprbuilder_tb.__path__[0], 'data',
                                   'spoligo_new.fasta'))
      p_old_blast = str(PurePath(crisprbuilder_tb.__path__[0], 'tmp', item
                                 + "_old.blast"))
      p_new_blast = str(PurePath(crisprbuilder_tb.__path__[0], 'tmp', item
                                 + "_new.blast"))

      try:
          completed = subprocess.run("blastn -num_threads 12 -query " +
                                     p_spoligo_old + " -evalue 1e-6 -task "
                                     "blastn -db " + repitem + " -outfmt "
                                     "'10 qseqid sseqid sstart send qlen "
                                     "length score evalue' -out " +
                                     p_old_blast, shell=True, check=True)
          completed.check_returncode()
      except subprocess.CalledProcessError:
          print("We can't proceed blasting file.")

      try:
          completed = subprocess.run("blastn -num_threads 12 -query " +
                                     p_spoligo_new + " -evalue 1e-6 -task "
                                     "blastn -db " + repitem + " -outfmt "
                                     "'10 qseqid sseqid sstart send qlen "
                                     "length score evalue' -out " +
                                     p_new_blast, shell=True, check=True)
          completed.check_returncode()
      except subprocess.CalledProcessError:
          print("We can't proceed blasting file.")

      for pos, spol in enumerate(['old', 'new']):
          p_blast = str(PurePath(crisprbuilder_tb.__path__[0], 'tmp', item
                                 + '_' + spol + '.blast'))
          p_fasta = str(PurePath(crisprbuilder_tb.__path__[0], 'data',
                                 'spoligo_' + spol + '.fasta'))

          with open(p_blast) as file:
              matches = file.read()
              nb_max = open(p_fasta).read().count('>')
              for k in range(1, nb_max + 1):
                  if matches.count('espaceur' + spol.capitalize() + str(k)
                                   + ',') >= 5:
                      dico_afr[item]['spoligo' + ['', '_new'][pos]] \
                                     += '\u25A0'
                  else:
                      dico_afr[item]['spoligo' + ['', '_new'][pos]] \
                                     += '\u25A1'

          dico_afr[item]['spoligo' + ['', '_new'][pos] + '_nb'] = [
              matches.count('espaceur' + spol.capitalize() + str(k) + ',')
              for k in range(1, nb_max + 1)]
          try:
              move(p_blast, rep)
          except FileNotFoundError:
              print(p_blast, " is already in the SRA directory.")
\end{verbatim}

    You will read the message:

    \begin{verbatim}
  The spoligotypes are being blasted
  The spoligo-vitro are being blasted
\end{verbatim}

    The different files ERR2704808\_*.blast will then be moved to
\textbf{REP/sequences/ERR2704808}

    As a result, the programm will display the following information:

\includegraphics[width=16.5cm]{spoligo1.png}

    The same process is applied to the spoligotypes\_vitro.

\includegraphics[width=16.5cm]{spoligo2.png}

    The Spoligotype International Type and Spoligotype International Type
silico will be retrieved according to the following code:

\begin{verbatim}
  if 'SIT' not in dico_afr[item] or dico_afr[item]['SIT'] == '':
      fonctions.add_spoligo_dico('SIT', dico_afr, item, spol_sit)

  if 'SIT_silico' not in dico_afr[item]:
      fonctions.add_spoligo_dico('SIT_silico', dico_afr, item, spol_sit)
\end{verbatim}

    which will display the following message:

    \begin{verbatim}
  We're adding the SIT: X to the database
  We're adding the SIT_silico: X to the database
\end{verbatim}

    Finally, the lineage will be defined by comparing the blast files with
the different lineages L6+animal, Principal Genotyping Group, Principal
Genotyping Group-cp, Coll, Pali, Shitikov and Stucki, as for example in
the code:

\begin{verbatim}
  if 'lineage_Pali' not in dico_afr[item]:
      lignee = []
      lignee_snp = fonctions.to_reads('Pali')
      print("We're adding the lineage according to the SNPs Pali")

      for item2, pos0 in enumerate(lignee_snp):
          seq1, seq2 = lignee_snp[pos0][:2]
          p_blast = str(PurePath(crisprbuilder_tb.__path__[0], 'tmp',
                                 'snp_Pali.blast'))
          with open(fonctions.P_FASTA, 'w') as f_fasta:
              f_fasta.write('>\n' + seq2)
          cmd = "blastn -query " + fonctions.P_FASTA + " -num_threads 12" \
                " -evalue 1e-5 -task blastn -db " + repitem + \
                " -outfmt '10 sseq' -out " + p_blast
          system(cmd)
          with open(p_blast) as f_blast:
              formatted_results = f_blast.read().splitlines()

          nb_seq1 = fonctions.to_nb_seq(seq1, formatted_results, 16, 20,
                                        21, 25)
          nb_seq2 = fonctions.to_nb_seq(seq2, formatted_results, 16, 20,
                                        21, 25)

          if nb_seq2 > nb_seq1:
              lignee.append(lignee_snp[pos0][2])

      lignee = [u for u in sorted(set(lignee))]

      dico_afr[item]['lineage_Pali'] = lignee
\end{verbatim}

    During its work the program will display the following message:

    \begin{verbatim}
  We're adding the lineage according to the SNPs L6+animal
  We're adding the lineage according to the SNPs PGG
  The lineage is being updated.
  We're adding the lineage according to the SNPs Coll
  We have selected specific reads to compare with different lineages
  We're adding the lineage according to the SNPs Pali
  We have selected specific reads to compare with different lineages
  We're adding the lineage according to the SNPs Shitikov
  We have selected specific reads to compare with different lineages
  We're adding the lineage according to the SNPs Stucki
\end{verbatim}

    which will produce the following result:

    \begin{verbatim}
  lineage_L6+animal: 1
  lineage_PGG_cp: ['1', 'X']
  lineage_PGG: X
  lineage_Coll: ['4', '4.9', '5']
  lineage_Pali: ['1']
  lineage_Shitikov: []
  Lignee_Stucki: ['4.10']
\end{verbatim}

    Some general information will be retrieved from the dataset Origines or
directly from NCBI, according to the code:

\begin{verbatim}
  if 'Source' not in dico_afr[item]:
      for ref in bdd.Origines:
          if item in ref['run accessions']:
              for elt in ['Source', 'Author', 'study accession number',
                          'location']:
                  dico_afr[item][elt] = ref.get(elt)

  if 'taxid' not in dico_afr[item]:
      dicobis = fonctions.get_info(item)
      for elt in dicobis:
          dico_afr[item][elt] = dicobis[elt]
\end{verbatim}

    If the SRA belongs to Origines, the following message will be displayed:

    \begin{verbatim}
  ERR2704808 is in the database Origines
\end{verbatim}

    which will produce the following result:

    \begin{verbatim}
  Source: Unexpected Genomic and Phenotypic Diversity of Mycobacterium africanum   Lineage 5 Affects Drug Resistance, Protein Secretion, and Immunogenicity
  Author: Ates et al. 2018
  study accession number: PRJEB25506
  location: France
  date: 2007
  SRA: ERS2280688
  center: DST/NRF Centre of Excellence for Biomedical TB research, SAMRC Centre for TB   Research
  strain: 
  taxid: 33894
  name: Mycobacterium tuberculosis variant africanum
  study: ena-STUDY-DST/NRF Centre of Excellence for Biomedical TB research, SAMRC Centre for TB Research-10-03-2018-12:26:21:907-341
  bioproject: PRJEB25506
\end{verbatim}





% LES TESTS DU PACKAGE -----------------------
\chapter{Tester le package}

Les tests font partie du processus de développement et sont effectués dans chacune des phases de création du code afin de pouvoir continuer à l'étape suivante.

Plusieurs niveaux de tests doivent être effectués pour valider le package avant publication. Ils nécessitent un environnement de développement dont nous avons déjà parlé et un environnement de test. Celui-ci est re-créé pour chaque système d'exploitation faisant partie de la campagne de tests. Il doit simuler le cas le plus défavorable, c'est à dire qu'il doit être représentatif d'un système d'exploitation "vierge" ne disposant pas des dépendances nécessaires à l'exécution du package. Il doit toutefois fonctionner avec Python 3 par défaut ou appeler le package à l'aide de Python 3. 

Notre campagne de tests comporte les démarches suivantes :
\begin{itemize}
\item durant la création de chaque fonction, les tests unitaires sont effectués à l'aide de l'environnement de développement,
\item au moment du regroupement du code et des différents modules, les tests d'intégration utilisent l'environnement de développement
\item lors d'une modification de code, les tests de non-régression utilisent l'environnement de développement,
\item lorsque le package est construit, les tests de performance et les tests fonctionnels s'appuient également sur l'environnement de développement
\item en dernier lieu, les tests d'installation en fonction de différents systèmes d'exploitation nécessitent un environnement de test,
\item finalement, les tests de configuration pour déterminer les systèmes les mieux adaptés utilisent également un environnement de test.
\end{itemize}







% TESTS UNITAIRES ---------
\section{Les tests unitaires, le module unittest}

Les tests unitaires consistent à évaluer individuellement les composants de l'application (parties de code autonomes, fonctions, ...), en terme de qualité et validation des résultats attendus.

Les tests unitaires sont d'abord effectués manuellement, fonction par fonction, en évaluant chaque résultat obtenu.

Il faut donc comprendre le fonctionnement, puis tester chaque portion de code et chaque fonction individuellement avec des paramètres choisis avant de l'incorporer dans le module \_\_main\_\_.py. Il est donc nécessaire d'adapter au reste du code les fonctions déjà écrites, les documenter en anglais en vue d'une utilisation ultérieure, les rendre performantes en utilisant des compréhensions de listes, éviter les erreurs potentielles en rajoutant des blocs \textbf{try ... except} et des méthodes \textbf{.setdefault} et \textbf{.get}. Il faut également créer de nouvelles fonctions pour éviter la répétition de code.

Puis nous utilisons le framework \index{unittest}\textit{unittest} intégré dans la distribution standard de Python3.

TODO - EXPLICATIONS unittest





% LES TESTS D'INTEGRATION -----------------------------
\section{les tests d'intégration}

Les tests d'intégration permettent de valider l'inter-utilisabilité des différentes unités de programmes  et des différents modules entre eux. Nous réalisons les tests d'intégration directement dans l'environnement de développement que nous avons construit.

Pour cela, nous nous plaçons à la racine du package et nous exécutons directement le code du module \textbf{\_\_main\_\_.py} par la commande 

\begin{verbatim}
  cd crisprbuilder_tb
  python __main__.py
\end{verbatim}



% LES PROBLEMES RENCONTRES -----------------------
\subsection{Les problèmes rencontrés}

Une fois que le code a été testé individuellement avec comme valeur pour le SRA ERR2704808, qu'il a été rendu compatible pour chaque fonction, chaque variable et chaque paramètre, qu'il a passé avec succès l'analyse de pylint et les tests statiques de l'EPI PyCharm, nous avons rencontré les problèmes suivants :  
\begin{itemize}
\item subprocess.run : au moment de l'exécution du code, une erreur de type \texttt{  XX} apparaît. Nous nous rendons compte que l'installation manuelle de \textit{subprocess.run}, loin de résoudre le problème, empêche la bonne exécution du code. Il est donc recommandé de ne pas l'installer et de se contenter de la version native présente dans Python.
\item parallel-fastq-dump :
\item la gestion des exceptions : la gestion des exceptions avec des blocs \textbf{try ... except FileNotFoundError} ne permet pas au programme de déplacer un fichier vers un répertoire contenant déjà ce fichier. Ce problème est plus sensible au moment des tests car nous utilisons à plusieurs reprises le même SRA. Toutefois, il pourrait également advenir à un utilisateur qui aurait inscrit plusieurs fois sur une liste le même SRA. Il convient donc de tester la présence d'un fichier dans un répertoire avant de le déplacer.
\end{itemize}


La première erreur qui apparaît est l'impossibilité pour l'interpréteur Python de trouver les modules \textbf{fonctions.py} et \textbf{bdd.py}. Dans le module \textbf{\_\_main\_\_.py}, il faut donc importer le package \textit{crisprbuilder\_tb}, puis importer les modules \textbf{crisprbuilder\_tb.fonctions.py} et \textbf{crisprbuilder\_tb.bdd.py} sans oublier à chaque fois le nom du package, pour que l'interpréteur parvienne à trouver ces modules. Ceci est un peu surprenant car ces modules se situent également à la racine du package, et devraient donc être reconnus automatiquement.




% PYLINT --------------
\subsection{Le respect des règles du PEP avec pylint}

\index{pylint}\textit{pylint} fournit une note entre 0 et 10 qui reflète le respect des règles du PEP-8\footnote{\index{PEP-8}\textbf{PEP-8:} style guide for Python code} et du PEP-257\footnote{\index{PEP-257}\textbf{PEP-257:} docstring conventions}, notamment en ce qui concerne la lisibilité du code en terme d'espaces entre les signes, de longueur maximale pour chaque ligne (80 caractères) et d'indentation pour assurer la compréhension lors d'un retour à la ligne. \textit{pylint} reprend également les erreurs de structure de code, les manques de définition de variables ou les ambiguïtés dans l'utilisation de variables locales portant le même nom. Toutefois, il comprend mal l'utilisation des compréhensions de listes et des méthodes telles que .setdefault pour récupérer la valeur d'une variable dans un dictionnaire.

L'exécution de \textit{pylint} se fait directement en ligne de commande en se plaçant dans le package, à hauteur du dossier parent du fichier à tester (par exemple ici \_\_main\_\_.py) suivant l'instruction

\begin{verbatim}  cd crisprbuilder_tb
  pylint __main__.py\end{verbatim}

Comme \textit{pylint} considère que les modules ne devraient pas excéder 1000 lignes, nous avons développé notre module initial \_\_main\_\_.py en trois modules \_\_main\_\_.py, fonctions.py et bdd.py. Nous nous sommes par ailleurs astreints aux règles du PEP pour obtenir une note de 9.72 / 10 avec les commentaires suivants concernant le module \_\_main\_\_.py. 

\begin{verbatim}  pylint __main__.py
  ************* Module __main__
  __main__.py:36:0: R0914: Too many local variables (57/15) (too-many-locals)
  __main__.py:152:23: W0123: Use of eval (eval-used)
  __main__.py:160:23: W0123: Use of eval (eval-used)
  __main__.py:606:0: R1721: Unnecessary use of a comprehension (unnecessary-comprehension)
  __main__.py:643:0: R1721: Unnecessary use of a comprehension (unnecessary-comprehension)
  __main__.py:679:0: R1721: Unnecessary use of a comprehension (unnecessary-comprehension)
  __main__.py:585:16: W0612: Unused variable 'item2' (unused-variable)
  __main__.py:36:0: R0912: Too many branches (88/12) (too-many-branches)
  __main__.py:36:0: R0915: Too many statements (317/50) (too-many-statements)
  __main__.py:734:0: R0914: Too many local variables (17/15) (too-many-locals)
  __main__.py:734:0: R0912: Too many branches (19/12) (too-many-branches)
  __main__.py:734:0: R0915: Too many statements (101/50) (too-many-statements)

  ------------------------------------------------------------------
  Your code has been rated at 9.72/10\end{verbatim}

De la même façon, le module fonctions.py a obtenu la note de 9.80 / 10 avec les commentaires suivants

\begin{verbatim}  pylint fonctions.py
  ************* Module fonctions
  fonctions.py:372:13: W1510: Using subprocess.run without explicitly set `check` is not recommended. (subprocess-run-check)
  fonctions.py:380:0: R0913: Too many arguments (6/5) (too-many-arguments)
  fonctions.py:400:0: R0913: Too many arguments (7/5) (too-many-arguments)

  -----------------------------------
  Your code has been rated at 9.80/10\end{verbatim}

Le module bdd.py ne contenant que le dictionnaire Origines n'a pas été évalué par \textit{pylint}.

S'agissant d'un test statique, le code n'est pas exécuté et la performance du code n'est pas prise en compte lors de l'évaluation faite par \textit{pylint}. Ceci explique que \textit{pylint} peut reprocher l'utilisation injustifiée de listes compréhensives, sans tenir compte de l'efficacité d'un tel traitement.

TODO PROBLEME PASSAGE PACKAGE
CHEMINS D'ACCES




% LES TESTS DE NON REGRESSION ---------------------------------
\section{Les tests de non-régression}

Les tests de non-régression permettent de vérifier que les modifications apportées au programme durant l'ensemble de la phase de test n'ont pas altérées le fonctionnement du package.

Pour cela, lorsqu'un changement est effectué, les résultats obtenus doivent être comparés aux résultats pécédemment obtenus. Nous nous sommes alors exclusivement basé sur les commandes

\begin{verbatim}python -m crisprbuilder_tb --print 0}\end{verbatim}

et 

\begin{verbatim}  python -m crisprbuilder_tb --collect ERR2704812\end{verbatim}

pour procéder aux vérifications aprés modification de code.



% LE VERSIONING AVEC GIT -------------------------
\subsection{Le versioning avec Git}

L'utilisation de l'outil de versioning \index{Git}\textit{Git} a constitué une aide précieuse au cours de chaque modification significative du code, permettant de revenir en arrière en cas de besoin et de ne pas perdre le travail effectué. Ce stage a été l'occasion de manipuler régulièrement les principales commandes \textit{Git}. 

Notons à ce propos que \textit{Poetry} construit un dossier \textbf{crisprbuilder\_tb} au moment de la création du package avec l'instruction

 \begin{verbatim}  poetry new crisprbuilder_tb}\end{verbatim}

et que \textit{Git} construit également un autre dossier \textbf{crisprbuilder\_tb} au moment de la création d'un répertoire \textit{Git} avec l'instruction

\begin{verbatim}  git clone https://github.com/stephane-robin/crisprbuilder_tb.git}\end{verbatim}

Il est donc nécessaire de créer d'abord le package avec \textit{Poetry} puis d'initaliser ce répertoire en liaison avec un dépôt \textit{Git}, en se plaçant à la racine de ce répertoire eten utilisant l'instruction

\begin{verbatim}
  git init
  git remote https://github.com/stephane-robin/crisprbuilder_tb.git
  git add .
  git commit -m "first commit"
  git push origin master
\end{verbatim} 




% LES TESTS D'INSTALLATION -----------------------------
\section{Les tests d'installation}

Avant de publier le package, il faut tester son comportement à l'installation en dehors de l'environnement de développement. Pour cela, il est possible de le publier officieusement sur la plateforme de test testPyPI. Il faut alors se placer à la racine du package et lancer en ligne de commande l'instruction
\begin{verbatim}  twine upload --repository testpypi dist/*\end{verbatim}

On peut donc télécharger un package à partir d'index différents de PyPI, comme par exemple testPyPI. Toutefois, les dépendances ne sont pas nécessairement répertoriées dans cet index. Cela induit dans ce cas une erreur au téléchargement et interdit l'installation du package. il faut donc faire référence à PyPI pour le téléchargement des dépendances. Par exemple, l'installation de CRISPRbuilder\_TB à partir de testPyPI se fait à l'aide de l'instruction suivante, après s'être assuré que \textit{pip} s'exécute avec une version 3 de Python

\begin{verbatim}  pip install --index-url https://test.pypi.org/simple/ --extra-index-url 
  https://pypi.org/simple/ crisprbuilder_tb\end{verbatim} 

Attention à bien respecter l'espace entre \texttt{ simple/} et \texttt{crisprbuilder\_tb}.

L'instruction \texttt{ \textemdash \textemdash index \textemdash url} permet l'installation du package à partir de textPyPI alors que l'instruction \texttt{ \textemdash \textemdash extra \textemdash index \textemdash url} permet l'installation des dépendances à partir de PyPI.

Il peut arriver que testPyPI n'installe pas la dernière version. Dans ce cas, il convient de préciser la version souhaitée du package, par exemple pour la version 0.1.2, il faut écrire

\begin{verbatim}  pip install --index-url https://test.pypi.org/simple/ --extra-index-url 
  https://pypi.org/simple/ crisprbuilder_tb==0.1.2\end{verbatim} 

A noter qu'il ne faut utiliser de guillemets autour de la version du package.

Il est fréquent qu'il s'affiche à ce moment-là le message d'erreur suivant

\begin{verbatim}  ERROR: Could not find a version that satisfies the requirement crisprbuilder_tb==0.1.2 (from versions: 0.0.1, 0.0.2, 0.0.3, 0.0.4, 0.0.5, 0.1.0, 0.1.1)
ERROR: No matching distribution found for crisprbuilder_tb==0.1.2\end{verbatim}

Dans ce cas, la répétition de l'instruction précédente résout souvent le problème.

Une fois que l'installation est validée à partir de testPyPI et que les modifications nécessaires ont été effectuées dans le code du package, on peut publier le package sur PyPI et procéder aux tests sur la version proposée aux utilisateurs avec la commande

\begin{verbatim}
  pip install crisprbuilder_tb
\end{verbatim}

Lorsqu'une version antérieure de CRISPRbuilder\_TB existe déjà sur l'ordinateur, il peut arriver que l'installation d'une version plus récente échoue. Il est possible de la mettre à niveau de la façon suivante
\begin{verbatim}
  pip install --upgrade crisprbuilder_tb
\end{verbatim}

En cas de difficulté rencontrée, on peut forcer la mise à niveau en supprimant d'abord le package \textit{crisprbuilder\_tb}
\begin{verbatim}
  pip uninstall crisprbuilder_tb
  pip install crisprbuilder_tb
\end{verbatim}

Les tests d'installation permettent de s'assurer que l'utilisateur sera en mesure d'installer le package si il dispose d'un système d'exploitation Linux, MacOS ou Microsoft Windows. Pour simuler le fonctionnement de ces systèmes, nous choisissons de travailler sur les quatre machines virtuelles suivantes créées par \textit{VirtualBox}, toutes fonctionnant en 64 bits : 
\begin{itemize}
\item Ubuntu 18.04 LTS, 
\item Ubuntu 20.04 LTS, 
\item macOS 10.12 Sierra, 
\item Microsoft Windows 10.
\end{itemize}



% L'UTILISATION DE VIRTUALBOX
\subsubsection{L'utilisation de VirtualBox}

Afin de tester le comportement de l'application à l'installation et au fonctionnement au sein de différents systèmes d'exploitation, nous créons artificiellement des plateformes de test vierges grâce à \index{VirtualBox}\textit{VirtualBox}. Nous configurons systématiquement Python dans sa dernière version qui est la 3.8 et nous installons \textit{pip}.

\begin{verbatim}
MISE A JOUR PYTHON
  /usr/ A VERIFIER
  apt-get install pip
\end{verbatim}

Nous commençons par télécharger des images \textit{.iso} des différents systèmes d'exploitation, que nous clonons avant de commencer les tests afin de conserver une version vierge pour pouvoir revenir en arrière en cas de besoin :
\begin{itemize}
\item pour Ubuntu 18.04 LTS, nous choisissons la version 64-bit Server Install Image car nous n'avons pas besoin d'interface graphique pour réaliser nos tests. La version de Python par défaut de ce système est 2.7.17. Il existe également une version 3.6.9 de Python,
\item pour Ubuntu 20.04 LTS, la version de Python par défaut de ce système est 3.8.2,
\item pour MacOS 10.12 Sierra, 
\item pour Microsoft Windows 10, 
\end{itemize}

Nous commençons les tests en rajoutant dans la description de chaque système toutes les installations effectuées afin que le package fonctionne correctement.

Les premiers tests d'installation avec Ubuntu 18.04 LTS s'avèrent défaillants car nous n'avons pas précisé l'adresse de PyPI pour l'installation des dépendances, ce qui a entraîné des difficultés d'installation automatique des modules au regard des contraintes imposées par le fichier \textbf{poetry.lock}. Pour s'assurer que les dépendances soient bien installées, nous avons dans un premier temps proposé que l'utilisateur le fasse manuellement en suivant les consignes données dans la documentation et à l'aide de l'instruction \texttt{pip install nom\_module}. Pour simplifier le travail de l'utilisateur, nous avons pensé inclure un fichier \textbf{requirements.txt} dans le package et demander à l'utilisateur d'exécuter \texttt{XXX}. Toutefois, cela suppose que l'utilisateur soit en mesure de trouver l'emplacement de son package dans son système avant d'utiliser le fichier \textbf{requirements.txt}, ce qui n'est pas nécessairement évident sur MacOS par exemple. Cela ne nous semble pas être conforme à l'esprit d'un package dont les dépendances doivent s'installer automatiquement grâce qu fichier \textbf{poetry.lock}. De ce fait, nous avons abandonné cette idée, et après avoir compris que les dépendances pouvaient être téléchargées sur PyPI, nous avons correctement effectué l'installation de CRISPRbuilder\_TB. Malheureusement l'exécution de l'instruction

\begin{verbatim}
  python -m crisprbuilder_tb --collect ERR2704808
\end{verbatim}

conduit au message d'erreur suivant

\begin{verbatim}
XXX
\end{verbatim}

ce qui montre qu'un système vierge ne parvienne pas à exécuter \textit{parallel-fastq-dump}, même si ce module a été préalablement installé par \textit{Poetry}, probablement car il n'en connaît pas le chemin d'accès.

Pour que l'installation fonctionne correctement, il faut donc s'assurer que l'utilisateur dispose d'un version fonctionnelle de \textit{parallel-fastq-dump} avant l'installation de CRISPRbuilder\_TB, en la testant avec la commande 

\begin{verbatim}
  parallel-fastq-dump --sra-id SRR1219899 --threads 4 --outdir out/ --split-files --gzip
\end{verbatim} 

Notons que dans le cas où une version de \textit{parallel-fastq-dump} existe déjà dans le système, \textit{Poetry} ne cherche pas à en installer une nouvelle version \texttt{  requirements already satisfied}.

On retient qu' il n'est donc pas nécessaire pour l'utilisateur d'installer manuellement les dépendances du projet, à l'exception de \textit{parallel-fastq-dump}. 










Une fois que l'application a été validée et publiée sur testPyPI, nous avons contrôlé la documentation au sein des modules et des fonctions, dans le fichier \textbf{README.md} et surtout dans le fichier \textbf{crisprbuilder\_tb.md}. 




CHOIX DU NOM SUR PYPI A USAGE UNIQUE

L’installation du package par n'importe quel utilisateur se fait grâce à l’instruction
\begin{verbatim}  pip install crisprbuilder_tb\end{verbatim}
après s'être assuré que \textit{pip} est bien configuré pour s'exécuter avec Python 3.


A RAJOUTER DANS LE NOTEBOOK
Dans le cas contraire, il convient de préciser
\begin{verbatim}  pip3 install crisprbuilder_tb\end{verbatim}



A RAJOUTER DANS LE NOTEBOOK AVEC LES SPOLIGO
ATTENTION A L'ESPACE AVANT CRISPRBUILDER LORS DE L'INSTALLATION A RAJOUTER AU NOTEBOOK

Au moment de l'installation, que ce soit à partir de PyPI ou d'un autre index tel que
testPyPI, l'utilisateur ne choisit pas l'emplacement d'installation. Celui-ci est défini automatiquement par le système en fonction des variables d'environnement. Par exemple, si on utilise une version particulière de Python avec \textit{pyenv}, alors le package pourra se trouver dans \textbf{\raisebox{-1ex}{\textasciitilde}/.pyenv/versions/3.6.5/lib/python3.6/}. Il est également fréquent de le retrouver dans \textbf{\raisebox{-1ex}{\textasciitilde}/.local/lib/python3.6/site-packages/} avec la plupart des différentes packages. Comme on ne connaît pas avec certitude l'emplacement dans lequel le package va s'installer, il convient de définir une variable d'environnement qui pointe vers l'emplacement d'installation.

Lors de l'exécution du package, il est nécessaire de l'appeler par son nom en utilisant l'indice "-m" signifiant "module". Il n'est pas utile de préciser l'utilisation de Python3 si le répertoire courant travaille déjà avec cette version. En revanche, les chemins relatifs dans les modules du package ne devront pas utiliser le nom crisprbuilder\_tb car celui-ci ne sera pas reconnu, une fois à la racine du package. EXPLICATIONS A CHANGER

Par défaut, Python cherche ses modules et packages dans la variable d'environnement \$PYTHONPATH. On peut alors consulter les différents chemins connus par cette variable d'environnement en exécutant l'instruction
\begin{verbatim}  python
  >>> import sys
  >>> print(sys.path)\end{verbatim}

afin d'obtenir une réponse sous forme de liste du type
\begin{verbatim}  ['',
  '\raisebox{-1ex}{\textasciitilde}/.pyenv/versions/3.6.5/lib/python36.zip',
  '\raisebox{-1ex}{\textasciitilde}/.pyenv/versions/3.6.5/lib/python3.6',
  '\raisebox{-1ex}{\textasciitilde}/.pyenv/versions/3.6.5/lib/python3.6/lib-dynload',    
  '\raisebox{-1ex}{\textasciitilde}/.local/lib/python3.6/site-packages',
  '\raisebox{-1ex}{\textasciitilde}/.pyenv/versions/3.6.5/lib/python3.6/site-packages']\end{verbatim}

On pourrait donc utiliser \texttt{sys.path[3]} comme chemin permettant d'accéder au répertoire parent de \textbf{crisprbuilder\_tb}. Toutefois, en fonction du système d'exploitation,  le 4ème élément de cette liste pour

Lorsque l'installation est réussie

\subsection{L'utilité de Anaconda}

Une fois l'installation réussie, le premier test de fonctionnement avec l'instruction

\begin{verbatim}
  python -m crisprbuilder_tb --print 0
\end{verbatim}

fournit le bon résultat.

En revanche, l'instruction

\begin{verbatim}
  python -m crisprbuilder_tb --collect ERR2704812
\end{verbatim}

produit une erreur dont voici le résumé

\begin{verbatim}
  File "~/.local/bin/parallel-fastq-dump" line 112, in <module> main()
  p = subprocess.Popen(["sra-stat", "--meta", "--quick", sra_id], stdout=subprocess.PIPE)
  File "/usr/lib/python3.8/subprocess.py", line 1364, in _execute_child raise child_exception_type(errno_num, err_msg, err_filename)
  FileNotFoundError: [Errno2] No such file or directory: 'sra-stat': 'sra-stat'
\end{verbatim}

Il semble au début qu'il faille installer le \textit{SRA Toolkit}. Pourtant, après configuration du \textit{Toolkit} suivant les recommandations du NCBI sur le site \url{https://ncbi.github.io/sra-tools/install_config.html}, le problème persiste.

Au cours des premiers tests d'installation, il est apparu qu'une fois les dépendances installées, elles n'étaient pas pour autant reconnues par un système vierge. Ainsi, l'erreur suivante s'affichait systématiquement

\begin{verbatim}

\end{verbatim}

puis l'erreur suivante s'affichait également

\begin{verbatim}

\end{verbatim}

Après avoir cherché du côté des chemins d'accès des différents fichiers support, il est apparu que le problème venait plutôt des variables d'environnement qui devaient être configurées. Ainsi, il est nécessaire que l'utilisateur ait convenablement répertorié les chemins d'accès vers ses fichiers exécutables et dans le cas présent les modules \textit{parallel-fastq-dump} et \textit{blastn}.

Renan Valieris sur son dépôt \url{https://github.com/rvalieris/parallel-fastq-dump} recommande l'utilisation de \textit{bioconda} pour installer le package \textit{parallel-fastq-dump}. En effet, nous nous sommes rendus compte sur le système Ubuntu 20.04 LTS, que l'installation à partir de \textit{  pip install parallel-fastq-dump} se fait correctement mais le package se trouve à la fois dans XXX et dans XXX, ce qui empêche le bon fonctionnement de l'instruction de test suivante

\begin{verbatim}
  parallel-fastq-dump -s ERR2704812
\end{verbatim} 

et lève l'erreur suivante

\begin{verbatim}
XXX
\end{verbatim}

Après vérification que la variable d'environnement \texttt{\$PATH} est bien configurée, le problème reste présent. Malgré le fait qu'il existe sûrement une solution à ce problème, l'installation de \textit{parallel-fastq-dump} par la commande \texttt{  conda install -c bioconda parallel-fastq-dump} le résout immédiatement. 

il est donc nécessaire d'interroger la variable d'environnement \texttt{\$PATH} avec la commande

\begin{verbatim}
  echo $PATH
\end{verbatim}

On doit obtenir un résultat du type
\begin{verbatim}

\end{verbatim}



% LES TESTS DE VALIDATION ------------------------------------
\section{Les tests de validation}

Les tests de validation permettent de vérifier la conformité du package développé par rapport à l'objectif et aux fonctionnalités initiales. A partir des tests fonctionnels, nous n'utilisons plus l'environnement de développement, mais un environnement de test qui peut être soit une machine virtuelle, soit un environnement neutre dénué de toute spécification, mais capable d'installer le package.

L'objectif initial était de fournir un package qui fournit des informations au \textit{SRA} dont la référence serait saisie en ligne de commande par un utilisateur. Ce dernier pourrait également fournir une liste de \textit{SRA} dans un fichier texte avec un \textit{SRA} par ligne. Il pourrait également consulter et modifier la base de données lineage.csv.

Nous fournissons au package un fichier au format \textit{.txt} comprenant plus qu'un \textit{SRA} par ligne. RESULTATS  

\begin{verbatim}
  python -m crisprbuilder_tb --collect ERR2704808 ne parvient pas à trouver les modules ...
\end{verbatim}

Les tests fonctionnels comprennent la validation de l'interface en ligne de commande. Il s'agit donc de vérifier que les lignes de commandes prévues pour l'exécution du code fournissent bien le résultat escompté. Pour cela, nous testons successivement les commandes

\begin{itemize}
\item \texttt{  python -m crisprbuilder\_tb \textemdash \textemdash help} qui fournit bien les informations relatives aux options du package,
\texttt{  python -m crisprbuilder\_tb \textemdash \textemdash print 0} qui affiche bien la liste demandée,
\item \texttt{  python -m crisprbuilder\_tb \textemdash \textemdash collect ERR2704808}
\item \texttt{  python -m crisprbuilder\_tb \textemdash \textemdash change 0}
\item \texttt{  python -m crisprbuilder\_tb \textemdash \textemdash remove 0}
\end{itemize}
\texttt{  python -m crisprbuilder\_tb \textemdash \textemdash add 0}


Nous considérons donc que l'utilisateur dispose déjà sur sa machine d'un SRA Toolkit fonctionnel, notamment des modules \textit{parallel-fastq-dump}, \textit{blast} et \textit{blastn} produisant les résultats escomptés avant d'installer de CRISPRbuilder\_TB.

% LES PROBLEMES LIES AUX CHEMINS D'ACCES ----------------------
\subsection{Les problèmes liés aux chemins d'accès}

L'incompatibilité des chemins d'accès entre les systèmes Posix et Windows nécessite la définition des chemins sans recourir aux caractères "/" ou "\textbackslash". Par ailleurs, comme le package va s'installer à des emplacements différents en fonction du système d'exploitation et des environnements de travail installés sur la machine (\textit{venv, anaconda, ...}), on ne peut pas définir d'adresse absolue mais privilégier plutôt des adresses relatives. Il est possible d'utiliser le module pahtlib, le module PurePath qui dépend du premier ou encore \_\_file\_\_. Ainsi, l'adresse  \textbf{crisprbuilder\_tb/REP/sequences} s'écrit :
\begin{itemize}
\item \textbf{pathlib.PurePath(crisprbuilder\_tb.\_\_path\_\_[0], 'REP', 'sequences')}
\item \textbf{os.path.join(path.dirname(\_\_file\_\_), 'REP', 'sequences)}
\end{itemize}






% LES TESTS DE PERFORMANCE ------------------------------------
\section{Les tests de performance}

L'objectif des tests de performance serait de valider la capacité des serveurs et réseaux pour supporter les charges d'accès importantes. Ceci ne s'applique pas vraiment à notre package, qui utilise lors de ses requêtes \textit{fastq} et \textit{blast} les serveurs du \index{NCBI}NCBI\footnote{\textbf{NCBI:} National Center for Biotechnology Information} et non pas ses propres serveurs. Si les serveurs de NCBI sont occupés, les réponses obtenues n'en seront que différées. CRISPRbuilder\_TB n'est pas une application Web, l'utilisation simultanée de plusieurs ordinateurs exécutant le package n'a pas d'incidence sur celui-ci.

En revanche, l'optimisation des performances de traitement des données doit être pris en compte car les fichiers de type \textit{.fasta} ont une taille comprise entre 1 et 3 Go, ce qui génère des délais importants lors de l'exécution du package.



% SUBPROCESS RUN-------------
\subsection{subprocess.run et os.system}

Au début de notre travail sur le code, nous avons transformé les lignes de commande Linux appelées par les méthodes Python \textbf{subprocess.run} et \textbf{os.system} en fonctions entièrement écrites en Python afin d'améliorer la portabilité de l'application, sans se limiter aux systèmes Linux. Nous avons constaté lors des premiers tests d'intégration un fort ralentissement du programme lorsque ces modifications étaient appliquées à l'ensemble du code, au vu de la taille importante des fichiers à lire par l'interpréteur. Nous avons donc décidé de revenir à l'utilisation de \textbf{subprocess.run} et \textbf{os.system}. Si cette démarche n'a aucune incidence pour la plateforme macOS, elle imposera en revanche un changement de lignes de commandes pour la plateforme Windows. Or, en fonction des versions du systéme Windows, l'utilisateur dispose d'une invite de commandes ou d'un PowerShell dont les instructions diffèrent. Nous avons donc choisi de tester dans le programme si le système est Posix ou Windows, puis de conserver les lignes de commande pour les système Posix et d'utiliser des fonctions Python pour les systèmes Windows. Cela entraîne de ce fait un réel manque de performance dans le traitement des données pour Windows. 

Pour mieux comprendre ce ralentissement, prenons un exemple sur un traitement simple consistant à concaténer deux fichiers \textit{.fasta}. L'instruction suivante

\begin{verbatim}os.system("cat SRR8368696_1.fasta SRR8368696_2.fasta > SRR8368696_shuffled_system.fasta")\end{verbatim}

est bien plus rapide qu'une fonction Python que nous pourrions définir pour concaténer et qui permettrait d'améliorer la portabilité du programme. En effet, nous constatons que le code ci-dessous exécuté 10 fois sur un système Ubuntu 18.04 LTS avec un processus Intel Pentium de 1,6 GHz 64 bits 4 coeurs

\begin{verbatim}
  import time
  import os

  def concat(p_f1, p_f2, p_shuffled):
      with open(p_f1, 'r') as file_1, open(p_f2, 'r') as file_2, \
              open(p_shuffled, 'w') as f_shuffled:
          lignes_1 = file_1.readlines()
          for elt in lignes_1:
              f_shuffled.write(elt)
          lignes_2 = file_2.readlines()
          for elt in lignes_2:
              f_shuffled.write(elt)

  debut_concat = int(round(time.time() * 1000))
  concat('SRR8368696_1.fasta', 'SRR8368696_2.fasta', 'SRR8368696_shuffled_concat.fasta')
  fin_concat = int(round(time.time() * 1000))
  temps_concat = fin_concat - debut_concat
  print(temps_concat)

  debut_system = int(round(time.time() * 1000))
  os.system("cat SRR8368696_1.fasta SRR8368696_2.fasta > SRR8368696_shuffled_system.fasta")
  fin_system = int(round(time.time() * 1000))
  temps_system = fin_system - debut_system
  print(temps_system)
\end{verbatim}

affiche un temps moyen d'exécution de l'instruction \textbf{os.system} de 19,3 secondes, alors qu'il est de 26,7 secondes lorsqu'on exécute la fonction \textit{concat}.

\includegraphics[width=10cm]{comparaison_concat.png}

\begin{tabular}{c|c|c|c|c|c|c|c|c|c|c}
concat (ms) & 31881 & 29452 & 31104 & 29307 & 28984 & 29330 & 28374 & 29775 & 30129 & 30608 \\
os.system (ms) & 27403 & 21099 & 21884 & 19798 & 21624 & 22838 & 21549 & 20971 & 21947 & 21502
\end{tabular}

Cette différence de quelques secondes pour une seule fonction entraîne par conséquence de nombreuses minutes de retard sur l'ensemble du code lors de son exécution. Les temps moyens d'exécution du programme pour chaque système d'exploitation sont relevés dans la rubrique \textit{Les tests de configuration}.




% PARALLEL FASTQ DUMP ----------------
\subsection{parallel-fastq-dump}

Le package utilise les modules Python de téléchargement et traitement de données provenant du NCBI \textit{fastq-dump} et \textit{blastn}. 

\textit{fastq-dump} est un module archaïque permettant de transformer des données du format \textit{.sra} au format \textit{.fastq}. Il est contenu dans le \textit{SRA Toolkit} du NCBI. Il peut s'avérer très lent en fonction de l'utilisation de la base de données en temps réel. 

L'utilisation de plusieurs threads devrait permettre de diviser le travail en différentes tâches effectuées simultanément, et donc de gagner du temps. Malheureusement, Python n'accepte pas nativement le travail multi-threads, ce qui ne permet pas de tirer profit de systèmes multi-coeurs. C'est en fait une caractéristique de CPython. Le GIL\footnote{\index{GIL}\textbf{GIL:} Global Interpreter Lock} est un mutex qui n'autorise le travail que d'un unique thread à la fois. Il protège l'accès aux objets Python, pour empêcher de multiples threads d'exécuter du code Python simultanément. Ce verrou est rendu nécessaire parce que la gestion de la mémoire sous CPython n'est pas thread-safe. Le module \textit{parallel-fastq-dump} résout partiellement ce problème de multi-threading et utilise l'implémentation CPython en incorporant du langage C dans son contenu. Il semble être à l'heure actuelle un bon compromis gratuit pour optimiser le traitement des données du format \textit{.sra} au format \textit{.fastq}. Notons que le \textit{SRA Tookit} est installé automatiquement au moment de l'installation de \textit{parallel-fastq-dump}.

REAL PYTHON ABOUT PYTHON THREADING




% BLAST -------------
\subsection{blast+}

\textit{blast} est également un outil du NCBI. Il permet de trouver des régions similaires entre plusieurs séquences génomiques. Il traite donc une quantité importante de données et ralentit de façon significative l'exécution du programme. Il compare des séquences de nucléotides ou de protéines à des séquences déjà présentes dans la base de données NCBI, puis calcule la signification statistique. \textit{blast} existe sous plusieurs formes \textit{blastx, tblastn, blastn, Primer-blast, smartblast, igblast, moleblast, ...}. Notre package utilise \textit{blastn} qui effectue des comparaisons entre nucléotides et dépend de la librairie \textit{blast}. Les performances de \textit{blast} sont optimisées avec la suite \textit{blast+} qui utilise le Toolkit C++ du NCBI. Ainsi notre package utilise l'outil \texttt{  makeblastdb} qui appartient à \textit{blast+}.






% LES TESTS DE CONFIGURATION --------------------------------
\section{Les tests de configuration}

Les tests de configuration cherchent à évaluer l'impact des différents systèmes d'exploitations et environnements matériels sur le fonctionnement d'une application.

Nous cherchons donc à définir la configuration matériele minimale afin que le package fonctionne correctement, ainsi que l'utilisabilité des différents systèmes d'exploitation.

TODO - CONFIG MINI






% CONCLUSION ----------------------
\chapter{Conclusion}

TODO

Ce stage m'a ouvert l'esprit vers le domaine de la bioinformatique et m'a permis de réfléchir à 

Notons qu'à terme, l'objectif du package sera de proposer une reconstitution du \textit{CRISPR}.
	

Ce stage m'a permis de pratiquer ... et de comprendre l'importance du test dans le développement d'un logiciel ou d'un package, car il a représenté une grande partie du travail.


	



UTILITE ???

pickle permet aux objets d'être sérialisés en fichiers sur disque et désérialisés dans le programme au moment de l'exécution.
	


% INDEX ------------------
\printindex



% =========
% BIBLIOTHEQUE
% =========
\begin{spacing}{0.5}
\bibliographystyle{}
\renewcommand{\bibname}{Références}
\begin{thebibliography}{10}

\bibitem{guyeux1}Guyeux C, Sola C, Noûs C, Refrégier G. \textit{CRISPRbuilder-TB:
"CRISPR-Builder for tuberculosis''. Exhaustive reconstruction of the
CRISPR locus in Mycobacterium tuberculosis complex using SRA}. PLoS
computational biology. 2020;submitted(PCOMPBIOL-S-20-00832-2)\\ \\

\bibitem{guyeux2}Guyeux C, Sola C, Refrégier G. \textit{Exhaustive reconstruction of the
CRISPR locus in M. tuberculosis complex using short reads BioRxiv}.
2019a. doi: https://doi.org/10.1101/844746\\ \\

 \bibitem{coll-preston}Coll F, Preston M, Guerra-Assuncao JA, Hill-Cawthorn G, Harris D,
Perdigao J, et al. \textit{PolyTB: A genomic variation map for Mycobacterium
tuberculosis. Tuberculosis} (Edinb). 2014;94(3):346-54(3):346-54. doi:
10.1016/j.tube.2014.02.005. PubMed PMID: 24637013\\ \\

\bibitem{stucki-brites}Stucki D, Brites D, Jeljeli L, Coscolla M, Liu Q, Trauner A, et al.
\textit{Mycobacterium tuberculosis lineage 4 comprises globally distributed and
geographically restricted sublineages}. Nature genetics.
2016;48(12):1535-43. doi: 10.1038/ng.3704. PubMed PMID: 27798628\\ \\

\bibitem{pali-ajaw}Palittapongarnpim P, Ajawatanawong P, Viratyosin W, Smittipat N,
Disratthakit A, Mahasirimongkol S, et al. \textit{Evidence for Host-Bacterial
Co-evolution via Genome Sequence Analysis of 480 Thai Mycobacterium
tuberculosis Lineage 1 Isolates}. Scientific reports. 2018;8(1):11597.
Epub 2018/08/04. doi: 10.1038/s41598-018-29986-3. PubMed PMID: 30072734;
PubMed Central PMCID: PMCPMC6072702\\ \\

\bibitem{shiti-kolchenko}Shitikov E, Kolchenko S, Mokrousov I, Bespyatykh J, Ischenko D, Ilina E, et al. \textit{Evolutionary pathway analysis and unified classification of
East Asian lineage of Mycobacterium tuberculosis}. Scientific reports.
2017;7(1):9227. doi: 10.1038/s41598-017-10018-5. PubMed PMID: 28835627;
PubMed Central PMCID: PMCPMC5569047\\ \\

\bibitem{kamerbeek-schouls}Kamerbeek J, Schouls L, Kolk A, van Agterveld M, van Soolingen D, Kuijper S, et al. \textit{Simultaneous detection and strain differentiation of
Mycobacterium tuberculosis for diagnosis and epidemiology}. J Clin
Microbiol. 1997;35(4):907-14. PubMed PMID: 9157152\\ \\

\bibitem{embden}van Embden JDA, van Gorkom T, Kremer K, Jansen R, van der Zeijst BAM,
Schouls LM. \textit{Genetic variation and evolutionary origin of the Direct
repeat locus of Mycobacterium tuberculosis complex bacteria}, J
Bacteriol. 2000;182:2393-401\\ \\

\bibitem{comas}Comas I. et al. \textit{Out-of-Africa migration and Neolithic coexpansion of Mycobacterium tuberculosis with modern humans}, Nat Genet. 45(10): 1176–1182. doi:10.1038/ng.2744\\ \\

\bibitem{coll}Coll F. et al., \textit{SpolPred : rapid and accurate prediction of Mycobacterium tuberculosis spoligotypes from short genomic sequences}, Bioinformatics. 28(22):2991–3\\ \\

\bibitem{brynildsrud}Brynildsrud O.B. et al., \textit{Global expansion of Mycobacterium tuberculosis lineage 4 shaped by colonial migration and local adaptation}, 4(10): eaat5869. doi: 10.1126/sciadv.aat5869\\ \\

\bibitem{driscoll}Driscoll J. R., \textit{Spoligotyping for molecular epidemiology of the Mycobacterium tuberculosis complex}, 551:117-28. doi: 10.1007/978-1-60327-999-4 10\\ \\

\bibitem{jinek}Jinek M. et al, \textit{A programmable dual-RNA-guided DNA endonuclease in adaptive bacterial immunity}, 337(6096):816-21. doi: 10.1126/science.1225829\\ \\

\bibitem{gori}Gori A. et al, \textit{Spoligotyping and Mycobacterium tuberculosis}, 11(8): 1242–1248. doi: 10.3201/1108.040982\\ \\

\bibitem{perry1}Perry S. et al., \textit{Infection with Helicobacter pylori is associated with protection against tuberculosis}, 5(1):e8804. doi: 10.1371/journal.pone.0008804\\ \\

\bibitem{perry2}Perry S. et al, \textit{The immune response to tuberculosis infection in the setting of Helicobacter pylori and helminth infections}, 141(6): 1232–1243. doi: 10.1017/S0950268812001823\\ \\

\bibitem{xia}Xia E. et al., \textit{SpoTyping: fast and accurate in silico Mycobacterium spoligotyping from sequence reads}, 8:19. doi 10.1186/s13073-016-0270-7\\ \\ 

\bibitem{dale}Dale JW. et al., \textit{Spacer oligonucleotide typing of bacteria of the Mycobacterium tuberculosis complex: recommendations for standardised nomenclature.}, 5(3):216–9\\ \\

\bibitem{iwai}Iwai H et al., \textit{CASTB (the comprehensive analysis server for the Mycobacterium tuberculosis complex): A publicly accessible web server for epidemiological analyses, drug-resistance prediction and phylogenetic comparison of clinical isolates. Tuberculosis.}, 95(6):843–4\\ \\

\bibitem{demay}Demay C. et al., \textit{SITVITWEB - A publicly available international multimarker database for studying Mycobacterium tuberculosis genetic diversity and molecular epidemiology.}, Infect Genet Evol. 12:755–66\\ \\

\bibitem{}McGovern Institute Channel, \textit{Genome Editing with CRISPR-Cas9}, \url{https://www.youtube.com/watch?v=2pp17E4E-O8}\\ \\

\bibitem{oneil}O'Neil M.B. et al., \textit{Lineage specific histories of Mycobacterium tuberculosis dispersal in Africa and Eurasia}, bioRxiv. 10.1101/210161\\ \\

\bibitem{ratovonirina}Ratovonirina N. H., \textit{Etudes descriptive, épidémiologique, moléculaire et spatiale des souches Mycobacterium tuberculosis circulant à Antananarivo, Madagascar}, Thèse de Doctorat de l'Université Paris-Saclay\\ \\

\bibitem{kamerbeek}Kamerbeek et al., \textit{Simultaneous detection and strain differentiation of Mycobacterium tuberculosis for diagnosis and epidemiology}, 35(4): 907–914\\ \\

\bibitem{mendis}Mendis C. et al., \textit{Insight into genetic diversity of Mycobacterium tuberculosis in Kandy, Sri Lanka reveals predominance of the Euro-American lineage}, International Journal of Infectious Diseases 87 84-91\\ \\

\bibitem{gomgnimbou},Gomgnimbou M. K. et al., \textit{Tuberculosis-Spoligo-Rifampin-Isoniazid Typing: an All-in-One Assay Technique for Surveillance and Control of Multidrug-Resistant Tuberculosis on Luminex Devices}, 51(11):3527-34. doi: 10.1128/JCM.01523-13\\ \\

\bibitem{couvin}Couvin D. et al., \textit{SpolSimilaritySearch - A web tool to compare and search similarities between spoligotypes of Mycobacterium tuberculosis complex}, 105:49-52. doi: 10.1016/j.tube.2017.04.007


\end{thebibliography}
\end{spacing}

\end{document}
